msgid ""
msgstr ""
"Project-Id-Version: slides 03\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-23 18:34+0300\n"
"PO-Revision-Date: 2023-02-23 18:37+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: en_UK\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.2.2\n"

#: lecture.adoc:26
msgid ""
"= Core Java. Лекция 3: Классы. Интерфейсы. Класс Object и его стандартные "
"методы\n"
"Иван Пономарёв, КУРС/МФТИ\n"
":revealjs_theme: black\n"
":revealjs_customtheme: white_course.css\n"
":revealjs_slideNumber:\n"
":revealjs_history:\n"
":revealjs_progress:\n"
":encoding: UTF-8\n"
":lang: ru\n"
"include::_doc_general_attributes.adoc[]\n"
":doctype: article\n"
":toclevels: 3\n"
":imagesdir: images\n"
":source-highlighter: highlightjs\n"
":highlightjsdir: highlight\n"
":icons: font\n"
":iconfont-remote!:\n"
":iconfont-name: font-awesome-4.7.0/css/font-awesome\n"
":revealjs_mouseWheel: true\n"
":revealjs_center: false\n"
":revealjs_transition: none\n"
":revealjs_width: 1600\n"
":revealjs_height: 900\n"
":stem: latexmath\n"
":zsp: &#8203;"
msgstr ""
"= Core Java. Lecture #3: Classes. Interfaces. Object class and its standard "
"methods\n"
"Ivan Ponomarev, Synthesized.io/MIPT\n"
":revealjs_theme: black\n"
":revealjs_customtheme: white_course.css\n"
":revealjs_slideNumber:\n"
":revealjs_history:\n"
":revealjs_progress:\n"
":encoding: UTF-8\n"
":lang: ru\n"
"include::_doc_general_attributes.adoc[]\n"
":doctype: article\n"
":toclevels: 3\n"
":imagesdir: images\n"
":source-highlighter: highlightjs\n"
":highlightjsdir: highlight\n"
":icons: font\n"
":iconfont-remote!:\n"
":iconfont-name: font-awesome-4.7.0/css/font-awesome\n"
":revealjs_mouseWheel: true\n"
":revealjs_center: false\n"
":revealjs_transition: none\n"
":revealjs_width: 1600\n"
":revealjs_height: 900\n"
":stem: latexmath\n"
":zsp: &#8203;"

#: lecture.adoc:29
msgid ":!figure-caption:"
msgstr ":!figure-caption:"

#: lecture.adoc:31
msgid "ponomarev@corchestra.ru"
msgstr "ponomarev@corchestra.ru"

#: lecture.adoc:33
msgid "icon:twitter[size=lg] @inponomarev"
msgstr "icon:twitter[size=lg] @inponomarev"

#: lecture.adoc:37
msgid ""
"[%notitle]\n"
"== Три главных слова\n"
"image::thethreewords.jpg[{image-50-width}]"
msgstr ""
"[%notitle]\n"
"== Three main words\n"
"image::thethreewords.jpg[{image-50-width}]"

#: lecture.adoc:39
msgid "== Всё есть класс"
msgstr "== Everything is a class"

#: lecture.adoc:43
msgid ""
"* Любой код -- метод некоторого класса\n"
"* Любые данные хранятся в полях некоторого класса\n"
"* Любые типы данных (исключая примитивные, но включая массивы) -- наследники "
"класса `Object`"
msgstr ""
"* Any code is a method of some class\n"
"* Any data is stored in fields of some class\n"
"* Any data type (except primitives, but including arrays) are inherited from "
"the `Object` class"

#: lecture.adoc:45
msgid "== Классы помещаются в пакеты"
msgstr "== Classes are located in packages"

#: lecture.adoc:51
msgid ""
"* `edu.phystech.foo`\n"
"* `edu.phystech.foo.bar`\n"
"* Каждый .java-файл начинается с объявления пакета: +\n"
"`package edu.phystech.hello;`\n"
"* В корне пакета может быть `package-info.java`, не содержащий классы, а "
"только JavaDoc над ключевым словом `package`."
msgstr ""
"* `edu.phystech.foo`\n"
"* `edu.phystech.foo.bar`\n"
"* Each .java file starts with a package declaration: +\n"
"`package edu.phystech.hello;`\n"
"* In the package directory can be `package-info.java`, containing no "
"classes, but only JavaDoc above the `package` keyword."

#: lecture.adoc:54
msgid ""
"* <Имя пакета>.<имя класса> задаёт полный идентификатор любого класса, "
"доступного в исходном коде или через библиотеки (например, `edu.phystech."
"hello.App`)\n"
"* Вложенные пакеты -- это _разные_ пакеты с точки зрения Java (package-"
"private классы одного пакета не будут видны в другом)"
msgstr ""
"* <Package Name>.<classname> specifies the full identifier of any class "
"available in your source code or from libraries (for example, `edu.phystech."
"hello.App`)\n"
"* Nested packages are _different_ packages in Java (package-private classes "
"of one package will not be visible in another)"

#: lecture.adoc:56
msgid "== Структура класса: переменные, конструкторы и методы"
msgstr "== Class structure: variables, constructors, and methods"

#: lecture.adoc:72
msgid ""
"[source, java]\n"
"----\n"
"class ClassName\n"
"{\n"
"   field1\n"
"   field2\n"
"   . . .\n"
"   constructor1\n"
"   constructor2\n"
"   . . .\n"
"   method1\n"
"   method2\n"
"   . . .\n"
"}\n"
"----"
msgstr ""
"[source, java]\n"
"----\n"
"class ClassName\n"
"{\n"
"   field1\n"
"   field2\n"
"   . . .\n"
"   constructor1\n"
"   constructor2\n"
"   . . .\n"
"   method1\n"
"   method2\n"
"   . . .\n"
"}\n"
"----"

#: lecture.adoc:74
msgid "== Определяем класс"
msgstr "== Define a class"

#: lecture.adoc:97
msgid ""
"[source,java]\n"
"----\n"
"package org.megacompany.staff;\n"
"class Employee {\n"
"  // instance fields\n"
"  private String name;\n"
"  private double salary;\n"
"  private LocalDate hireDay;\n"
"  // constructor\n"
"  public Employee(String n, double s, int year, int month, int day) {\n"
"    name = n;\n"
"    salary = s;\n"
"    hireDay = LocalDate.of(year, month, day);\n"
"  }\n"
"  // a method\n"
"  public String getName() {\n"
"    return name;\n"
"  }\n"
"  // more methods\n"
"  . . .\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"package org.megacompany.staff;\n"
"class Employee {\n"
"  // instance fields\n"
"  private String name;\n"
"  private double salary;\n"
"  private LocalDate hireDay;\n"
"  // constructor\n"
"  public Employee(String n, double s, int year, int month, int day) {\n"
"    name = n;\n"
"    salary = s;\n"
"    hireDay = LocalDate.of(year, month, day);\n"
"  }\n"
"  // a method\n"
"  public String getName() {\n"
"    return name;\n"
"  }\n"
"  // more methods\n"
"  . . .\n"
"}\n"
"----"

#: lecture.adoc:99
msgid "== Создаём и используем экземпляры класса"
msgstr "== Create and use instances of the class"

#: lecture.adoc:104
msgid ""
"[source,java]\n"
"----\n"
"//При необходимости, импортируем\n"
"import org.megacompany.staff.Employee;"
msgstr ""
"[source,java]\n"
"----\n"
"//If necessary, we can import a class from another package\n"
"import org.megacompany.staff.Employee;"

#: lecture.adoc:109
msgid ""
"//где-то в теле метода\n"
". . .\n"
"Employee hacker = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1);\n"
"Employee tester = new Employee(\"Tommy Tester\", 40000, 1990, 3, 15);"
msgstr ""
"//somewhere in the body of the method\n"
". . .\n"
"Employee hacker = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1);\n"
"Employee tester = new Employee(\"Tommy Tester\", 40000, 1990, 3, 15);"

#: lecture.adoc:112
msgid ""
"hacker.getName(); //returns \"Harry Hacker\"\n"
"----"
msgstr ""
"hacker.getName(); //returns \"Harry Hacker\"\n"
"----"

#: lecture.adoc:114
msgid "== Про инициализацию полей"
msgstr "== Field initialization"

#: lecture.adoc:116
msgid ""
"* В отличие от локальных переменных, поля можно не инициализировать явно."
msgstr "* Unlike local variables, fields can miss explicit initialization."

#: lecture.adoc:118
msgid ""
"* В этом случае примитивные типы получают значение по умолчанию (`0`, "
"`false`), а поля со ссылками -- значение `null`."
msgstr ""
"* In this case, primitive types are set to a default value (`0`, `false`), "
"and fields with references are set to `null`."

#: lecture.adoc:121
msgid ""
"* Проинициализировать поле по месту его определения не возбраняется: +\n"
"`int a = 42` или даже `int a = getValue()`. "
msgstr ""
"* It is not forbidden to initialize the field at the place of its "
"definition: +\n"
"`int a = 42` or even `int a = getValue()`. "

#: lecture.adoc:123
msgid "== Поле this"
msgstr "== `this` field"

#: lecture.adoc:127
msgid ""
"[source,java]\n"
"----\n"
"{ ..."
msgstr ""
"[source,java]\n"
"----\n"
"{ ..."

#: lecture.adoc:129
msgid "  int value;"
msgstr "  int value;"

#: lecture.adoc:134
msgid ""
"  setValue(int value) {\n"
"    //поле перекрыто аргументом\n"
"    this.value = value;\n"
"  }"
msgstr ""
"  setValue(int value) {\n"
"    // the field is hidden by an argument\n"
"    this.value = value;\n"
"  }"

#: lecture.adoc:140
msgid ""
"  registerMe(Registrator r) {\n"
"    //нужна ссылка на себя\n"
"    r.register(this); \n"
"  }\n"
"}"
msgstr ""
"  registerMe(Registrator r) {\n"
"    // a link to oneself is needed\n"
"    r.register(this); \n"
"  }\n"
"}"

#: lecture.adoc:142
msgctxt "lecture.adoc:142"
msgid "----"
msgstr "----"

#: lecture.adoc:145
msgid "== Объект передаётся по ссылке!"
msgstr "== Objects are passed by reference!"

#: lecture.adoc:150
msgid ""
"[source,java]\n"
"----\n"
"public class Employee {\n"
"    int age = 18;"
msgstr ""
"[source,java]\n"
"----\n"
"public class Employee {\n"
"    int age = 18;"

#: lecture.adoc:158
msgid ""
"    public static void main(String[] args) {\n"
"        Employee e = new Employee();\n"
"        int a = 1;\n"
"        foo(e, a);\n"
"        System.out.printf(\"%d - %d\", e.age, a);\n"
"        //prints 42 - 1\n"
"    }"
msgstr ""
"    public static void main(String[] args) {\n"
"        Employee e = new Employee();\n"
"        int a = 1;\n"
"        foo(e, a);\n"
"        System.out.printf(\"%d - %d\", e.age, a);\n"
"        //prints 42 - 1\n"
"    }"

#: lecture.adoc:166
msgid ""
"    static void foo(Employee e, int a) {\n"
"        //e passed by reference, a passed by value\n"
"        e.age = 42;\n"
"        a = 5;\n"
"    }\n"
"}\n"
"----"
msgstr ""
"    static void foo(Employee e, int a) {\n"
"        //e passed by reference, a passed by value\n"
"        e.age = 42;\n"
"        a = 5;\n"
"    }\n"
"}\n"
"----"

#: lecture.adoc:168
msgid "== Рождение, жизнь и смерть объекта"
msgstr "== Birth, life and death of an object"

#: lecture.adoc:171
msgid ""
"[source,java]\n"
"new Employee(\"Bob\")"
msgstr ""
"[source,java]\n"
"new Employee(\"Bob\")"

#: lecture.adoc:180
msgid ""
"[graphviz, \"life1.png\"]\n"
"-----\n"
"digraph G {\n"
" graph [ dpi = 200 ]; \n"
" rankdir=\"LR\";\n"
" object[shape=\"octagon\",label=\"Bob\"]\n"
"}\n"
"-----"
msgstr ""
"[graphviz, \"life1.png\"]\n"
"-----\n"
"digraph G {\n"
" graph [ dpi = 200 ]; \n"
" rankdir=\"LR\";\n"
" object[shape=\"octagon\",label=\"Bob\"]\n"
"}\n"
"-----"

#: lecture.adoc:183
msgctxt "lecture.adoc:183"
msgid "== Присвоение ссылки"
msgstr "== Reference assignment"

#: lecture.adoc:186
msgid ""
"[source,java]\n"
"Employee hacker = new Employee(\"Bob\");"
msgstr ""
"[source,java]\n"
"Employee hacker = new Employee(\"Bob\");"

#: lecture.adoc:197
msgid ""
"[graphviz, \"life2.png\"]\n"
"-----\n"
"digraph G {\n"
" graph [ dpi = 200 ]; \n"
" rankdir=\"LR\";\n"
" object[shape=\"octagon\",label=\"Bob\"]\n"
" ref[label=\"hacker\"];\n"
" ref->object;\n"
"}\n"
"-----"
msgstr ""
"[graphviz, \"life2.png\"]\n"
"-----\n"
"digraph G {\n"
" graph [ dpi = 200 ]; \n"
" rankdir=\"LR\";\n"
" object[shape=\"octagon\",label=\"Bob\"]\n"
" ref[label=\"hacker\"];\n"
" ref->object;\n"
"}\n"
"-----"

#: lecture.adoc:199
msgctxt "lecture.adoc:199"
msgid "== Присвоение ссылки"
msgstr "== Reference assignment"

#: lecture.adoc:202
msgid ""
"[source,java]\n"
"Employee junior = hacker;"
msgstr ""
"[source,java]\n"
"Employee junior = hacker;"

#: lecture.adoc:213
msgid ""
"[graphviz, \"life3.png\"]\n"
"-----\n"
"digraph G {\n"
" graph [ dpi = 200 ]; \n"
" rankdir=\"LR\";\n"
" object[shape=\"octagon\",label=\"Bob\"]\n"
" ref[label=\"hacker\"];\n"
" ref2[label=\"junior\"];\n"
" ref->object;\n"
" ref2->object;"
msgstr ""
"[graphviz, \"life3.png\"]\n"
"-----\n"
"digraph G {\n"
" graph [ dpi = 200 ]; \n"
" rankdir=\"LR\";\n"
" object[shape=\"octagon\",label=\"Bob\"]\n"
" ref[label=\"hacker\"];\n"
" ref2[label=\"junior\"];\n"
" ref->object;\n"
" ref2->object;"

#: lecture.adoc:216
msgid ""
"}\n"
"-----"
msgstr ""
"}\n"
"-----"

#: lecture.adoc:218
msgid "== Потеря ссылки"
msgstr "== Reference loss"

#: lecture.adoc:222
msgid ""
"[source,java]\n"
"hacker = null;\n"
"junior = new Employee(\"Charlie\");"
msgstr ""
"[source,java]\n"
"hacker = null;\n"
"junior = new Employee(\"Charlie\");"

#: lecture.adoc:239
msgid ""
"[graphviz, \"life4.png\"]\n"
"-----\n"
"digraph G {\n"
" graph [ dpi = 200 ]; \n"
" rankdir=\"LR\";\n"
" object[shape=\"octagon\",label=\"Bob\", fillcolor=\"grey\","
"style=\"filled\"]\n"
" object2[shape=\"octagon\",label=\"Charlie\"]\n"
" ref[label=\"hacker\"];\n"
" ref2[label=\"junior\"];\n"
" ref->null;\n"
" ref2->object2;\n"
" null[shape=\"circle\"];\n"
" ref3[style=\"invis\"];\n"
" ref3->object[style=\"invis\"];\n"
"}\n"
"-----"
msgstr ""
"[graphviz, \"life4.png\"]\n"
"-----\n"
"digraph G {\n"
" graph [ dpi = 200 ]; \n"
" rankdir=\"LR\";\n"
" object[shape=\"octagon\",label=\"Bob\", fillcolor=\"grey\","
"style=\"filled\"]\n"
" object2[shape=\"octagon\",label=\"Charlie\"]\n"
" ref[label=\"hacker\"];\n"
" ref2[label=\"junior\"];\n"
" ref->null;\n"
" ref2->object2;\n"
" null[shape=\"circle\"];\n"
" ref3[style=\"invis\"];\n"
" ref3->object[style=\"invis\"];\n"
"}\n"
"-----"

#: lecture.adoc:242
msgid "== Сборка мусора"
msgstr "== Garbage collection"

#: lecture.adoc:259
msgid ""
"[graphviz, \"life5.png\"]\n"
"-----\n"
"digraph G {\n"
" graph [ dpi = 200 ]; \n"
" rankdir=\"LR\";\n"
" object[shape=\"octagon\",label=\"Bob\", fillcolor=\"red\",style=\"invis\"]\n"
" object2[shape=\"octagon\",label=\"Charlie\"]\n"
" ref[label=\"hacker\"];\n"
" ref2[label=\"junior\"];\n"
" ref->null;\n"
" ref2->object2;\n"
" null[shape=\"circle\"];\n"
" ref3[style=\"invis\"];\n"
" ref3->object[style=\"invis\"];\n"
"}\n"
"-----"
msgstr ""
"[graphviz, \"life5.png\"]\n"
"-----\n"
"digraph G {\n"
" graph [ dpi = 200 ]; \n"
" rankdir=\"LR\";\n"
" object[shape=\"octagon\",label=\"Bob\", fillcolor=\"red\",style=\"invis\"]\n"
" object2[shape=\"octagon\",label=\"Charlie\"]\n"
" ref[label=\"hacker\"];\n"
" ref2[label=\"junior\"];\n"
" ref->null;\n"
" ref2->object2;\n"
" null[shape=\"circle\"];\n"
" ref3[style=\"invis\"];\n"
" ref3->object[style=\"invis\"];\n"
"}\n"
"-----"

#: lecture.adoc:263
msgid "== Области видимости"
msgstr "== Scopes"

#: lecture.adoc:272
msgid ""
"[cols=\"40a,60a\"]\n"
"|===\n"
"| *Область видимости* | *Кому доступно*\n"
"| `private`       | только классу\n"
"| package-private | только пакету (по умолчанию)\n"
"| `protected`     | классу, пакету, и классам-наследникам\n"
"| `public`        | всем\n"
"|==="
msgstr ""
"[cols=\"40a,60a\"]\n"
"|===\n"
"| *Scope* | *Visibility*\n"
"| `private` | class only\n"
"| package-private | package only (default)\n"
"| `protected` | class, package, and descendant classes\n"
"| `public` | everywhere\n"
"|==="

#: lecture.adoc:274
msgid "== Файлы с исходным кодом и классы"
msgstr "== Source code files and classes"

#: lecture.adoc:277
msgid ""
"* В одном .java файле может быть один публичный класс, названный так же, как "
"и .java-файл (`public class Foo` в файле `Foo.java`).\n"
"* Может быть сколько угодно package-private-классов, но это скорее плохая "
"практика."
msgstr ""
"* In a .java file, there can be only one public class, named the same as "
"the .java file ('public class Foo' in the 'Foo.java' file).\n"
"* There can be as many package-private classes as you like, but this is "
"rather a bad practice."

#: lecture.adoc:279
msgctxt "lecture.adoc:279"
msgid "== Наследование"
msgstr "== Inheritance"

#: lecture.adoc:297
msgid ""
"[plantuml, employeemanager, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 200 \n"
"class Employee {\n"
"  - name\n"
"  - salary\n"
"  + getName()\n"
"  + getSalary()\n"
"}\n"
"class Manager {\n"
"  - bonus\n"
"  + setBonus(bonus)\n"
"}\n"
"Employee <|- Manager\n"
"@enduml\n"
"----"
msgstr ""
"[plantuml, employeemanager, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 200 \n"
"class Employee {\n"
"  - name\n"
"  - salary\n"
"  + getName()\n"
"  + getSalary()\n"
"}\n"
"class Manager {\n"
"  - bonus\n"
"  + setBonus(bonus)\n"
"}\n"
"Employee <|- Manager\n"
"@enduml\n"
"----"

#: lecture.adoc:308
msgid ""
"[source,java]\n"
"----\n"
"public class Manager extends Employee {\n"
"  private double bonus;\n"
"  . . .\n"
"  public void setBonus(double bonus) {\n"
"    this.bonus = bonus;\n"
"  }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"public class Manager extends Employee {\n"
"  private double bonus;\n"
"  . . .\n"
"  public void setBonus(double bonus) {\n"
"    this.bonus = bonus;\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:310
msgctxt "lecture.adoc:310"
msgid "== Наследование"
msgstr "== Inheritance"

#: lecture.adoc:320
msgid ""
"[source,java]\n"
"----\n"
"// construct a Manager object\n"
"Manager boss = new Manager(\"Carl Cracker\", 80000, 1987, 12, 15);\n"
"boss.setBonus(5000);\n"
"Employee[] staff = new Employee[3];\n"
"staff[0] = boss;\n"
"staff[1] = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1);\n"
"staff[2] = new Employee(\"Tommy Tester\", 40000, 1990, 3, 15);"
msgstr ""
"[source,java]\n"
"----\n"
"// construct a Manager object\n"
"Manager boss = new Manager(\"Carl Cracker\", 80000, 1987, 12, 15);\n"
"boss.setBonus(5000);\n"
"Employee[] staff = new Employee[3];\n"
"staff[0] = boss;\n"
"staff[1] = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1);\n"
"staff[2] = new Employee(\"Tommy Tester\", 40000, 1990, 3, 15);"

#: lecture.adoc:324
msgid ""
"for (Employee e : staff)\n"
"  System.out.println(\"name=\" + e.getName() + \",salary=\" + e."
"getSalary());\n"
"----"
msgstr ""
"for (Employee e : staff)\n"
"  System.out.println(\"name=\" + e.getName() + \",salary=\" + e."
"getSalary());\n"
"----"

#: lecture.adoc:326
msgid "== {zsp}Наследование: единственный родительский класс{zsp}"
msgstr "== Inheritance: Single parent class"

#: lecture.adoc:337
msgid ""
"[plantuml, columnclasses, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 200 \n"
"Employee <|-- Manager\n"
"Employee <|-- Secretary\n"
"Employee <|-- Programmer\n"
"Manager  <|-- Executive\n"
"@enduml\n"
"----"
msgstr ""
"[plantuml, columnclasses, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 200 \n"
"Employee <|-- Manager\n"
"Employee <|-- Secretary\n"
"Employee <|-- Programmer\n"
"Manager  <|-- Executive\n"
"@enduml\n"
"----"

#: lecture.adoc:339
msgid "== Тип ссылки и тип объекта"
msgstr "== Reference type and object type"

#: lecture.adoc:348
msgid ""
"[plantuml, employeemanagerex, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 200 \n"
"Employee <|- Manager \n"
"Manager <|- Executive\n"
"@enduml\n"
"----"
msgstr ""
"[plantuml, employeemanagerex, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 200 \n"
"Employee <|- Manager \n"
"Manager <|- Executive\n"
"@enduml\n"
"----"

#: lecture.adoc:358
msgid ""
"[source,java]\n"
"----\n"
"  Executive ex = new Executive (...);\n"
"  //для ex доступны члены, объявленные в Manager, Employee и Executive\n"
"  Manager m = ex;\n"
"  //для m доступны члены, объявленные в Employee и Manager\n"
"  Employee e = m;\n"
"  //для e доступны члены, объявленные только в Employee\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"  Executive ex = new Executive (...);\n"
"  // members declared in Manager, Employee, and Executive are available for "
"ex\n"
"  Manager m = ex;\n"
"  // members declared in Employee and Manager are available for m\n"
"  Employee e = m;\n"
" // members declared in Employee only are available for m\n"
"----"

#: lecture.adoc:360
msgid "== Переопределение (overriding) методов"
msgstr "== Overriding methods"

#: lecture.adoc:372
msgid ""
"[source,java]\n"
"----\n"
"class Employee {\n"
"  private int salary;\n"
"  public int getSalary() {\n"
"    return salary;\n"
"  }\n"
"  public int getTotalPayout(){\n"
"    return getSalary();\n"
"  }\n"
"}"
msgstr ""
"[source,java]\n"
"----\n"
"class Employee {\n"
"  private int salary;\n"
"  public int getSalary() {\n"
"    return salary;\n"
"  }\n"
"  public int getTotalPayout(){\n"
"    return getSalary();\n"
"  }\n"
"}"

#: lecture.adoc:381
msgid ""
"class Manager extends Employee {\n"
"  private int bonus;\n"
"  @Override //не обязательная, но крайне желательная штука\n"
"  public int getTotalPayout() {\n"
"    return getSalary() + bonus;\n"
"  }\n"
"}\n"
"----"
msgstr ""
"class Manager extends Employee {\n"
"  private int bonus;\n"
"  @Override //this is not mandatory, but highly desirable thing\n"
"  public int getTotalPayout() {\n"
"    return getSalary() + bonus;\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:383
msgid "== Использование `super`"
msgstr "== Using `super`"

#: lecture.adoc:394
msgid ""
"[source,java]\n"
"----\n"
"class Manager extends Employee {\n"
"  private int bonus;\n"
"  @Override \n"
"  public int getTotalPayout() {\n"
"    return super.getTotalPayout() + bonus;\n"
"  }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"class Manager extends Employee {\n"
"  private int bonus;\n"
"  @Override \n"
"  public int getTotalPayout() {\n"
"    return super.getTotalPayout() + bonus;\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:396
msgid ""
"В отличие от `this`, `super` не указывает ни на какой объект (и его нельзя "
"никуда передать). Это лишь указание компилитору вызвать метод суперкласса."
msgstr ""
"Unlike `this`, `super` does not point to any object (and cannot be passed as "
"an argument). It just tells the compiler to call the superclass method."

#: lecture.adoc:398
msgid "== Ковариантность возвращаемых типов"
msgstr "== Covariance of return types"

#: lecture.adoc:402
msgid ""
"[plantuml, overriding, png]\n"
"----\n"
"@startuml"
msgstr ""
"[plantuml, overriding, png]\n"
"----\n"
"@startuml"

#: lecture.adoc:404
msgid "skinparam dpi 200 "
msgstr "skinparam dpi 200 "

#: lecture.adoc:408
msgid ""
"class Producer {\n"
"    + Object produce() \n"
"}"
msgstr ""
"class Producer {\n"
"    + Object produce() \n"
"}"

#: lecture.adoc:410
msgid "Producer <|-- IntegerProducer"
msgstr "Producer <|-- IntegerProducer"

#: lecture.adoc:414
msgid ""
"class IntegerProducer {\n"
"    + Integer produce()\n"
"}"
msgstr ""
"class IntegerProducer {\n"
"    + Integer produce()\n"
"}"

#: lecture.adoc:417
msgid "Object <|-- Integer"
msgstr "Object <|-- Integer"

#: lecture.adoc:420
msgid ""
"Producer . Object\n"
"IntegerProducer . Integer"
msgstr ""
"Producer . Object\n"
"IntegerProducer . Integer"

#: lecture.adoc:423
msgid ""
"@enduml\n"
"----"
msgstr ""
"@enduml\n"
"----"

#: lecture.adoc:426
msgid ""
"* Возвращаемый тип может быть того же типа или субтипа\n"
"* Типы аргументов обязаны совпадать"
msgstr ""
"* The return type can be of the same type or subtype\n"
"* Argument types must match"

#: lecture.adoc:428
msgid "== `final`-классы и методы"
msgstr "== `final` classes and methods"

#: lecture.adoc:435
msgid ""
"* Ключевое слово `final`:\n"
"** на уровне класса запрещает наследование класса\n"
"** на уровне метода запрещает наследование метода \n"
"* Зачем это нужно?\n"
"** Паттерн \"Шаблонный метод\"\n"
"** J. Bloch: 'Design and document for inheritance, or else prohibit it'"
msgstr ""
"* `final` keyword:\n"
"** at the class level prohibits class inheritance\n"
"** at the method level prohibit method inheritance \n"
"* Why?\n"
"** \"Template method pattern\"\n"
"** J. Bloch: 'Design and document for inheritance, or else prohibit it'"

#: lecture.adoc:437
msgid "== `sealed`-типы (Java 15+)"
msgstr "== `sealed` types (Java 15+)"

#: lecture.adoc:439
msgid "Наследоваться можно, но только тем, кому разрешено:"
msgstr ""
"A `sealed` class be subclassed, but only by those who explicitly allowed to:"

#: lecture.adoc:447
msgid ""
"[source,java]\n"
"----\n"
"public sealed class Pet \n"
"        permits \n"
"        //никакие другие не могут наследоваться от него\n"
"        Cat, Dog, Fish {\n"
"}"
msgstr ""
"[source,java]\n"
"----\n"
"public sealed class Pet \n"
"        permits \n"
"        //no others may inherit from Pet\n"
"        Cat, Dog, Fish {\n"
"}"

#: lecture.adoc:449
msgid "public final Cat {...}"
msgstr "public final Cat {...}"

#: lecture.adoc:451
msgid "public sealed Dog permits Hound, Terrier, Toy {...}"
msgstr "public sealed Dog permits Hound, Terrier, Toy {...}"

#: lecture.adoc:454
msgid ""
"public non-sealed Fish {...}\n"
"----"
msgstr ""
"public non-sealed Fish {...}\n"
"----"

#: lecture.adoc:456
msgid "== Важный пример: `sealed`-интерфейсы и record-ы"
msgstr "== Important example: `sealed` interfaces and `record`s"

#: lecture.adoc:458
msgid ""
"Пока не знаем ни что такое interface, ни что такое record, но просто "
"запомним: "
msgstr "We don't know what interface or record is yet, but just remember: "

#: lecture.adoc:463
msgid ""
"[source,java]\n"
"----\n"
"public sealed interface Expr\n"
"        permits Add, Subtract, Multiply, Divide, Literal {}"
msgstr ""
"[source,java]\n"
"----\n"
"public sealed interface Expr\n"
"        permits Add, Subtract, Multiply, Divide, Literal {}"

#: lecture.adoc:471
msgid ""
"//implicitly final!\n"
"public record Add(Expr left, Expr right) implements Expr {}\n"
"public record Subtract(Expr left, Expr right) implements Expr {}\n"
"public record Multiply(Expr left, Expr right) implements Expr {}\n"
"public record Divide(Expr left, Expr right) implements Expr {}\n"
"public record Literal(int value) implements Expr {}\n"
"----"
msgstr ""
"//implicitly final!\n"
"public record Add(Expr left, Expr right) implements Expr {}\n"
"public record Subtract(Expr left, Expr right) implements Expr {}\n"
"public record Multiply(Expr left, Expr right) implements Expr {}\n"
"public record Divide(Expr left, Expr right) implements Expr {}\n"
"public record Literal(int value) implements Expr {}\n"
"----"

#: lecture.adoc:474
msgid "== Перегрузка (overloading) методов"
msgstr "== Overloading methods"

#: lecture.adoc:490
msgid ""
"Сигнатура метода определяется его названием и типами аргументов:\n"
"[source,java]\n"
"----\n"
"//org.junit.jupiter.api.Assertions\n"
"void assertEquals(short expected, short actual)\n"
"void assertEquals(short expected, short actual, String message)\n"
"void assertEquals(short expected, short actual, Supplier<String> "
"messageSupplier)\n"
"void assertEquals(byte expected, byte actual)\n"
"void assertEquals(byte expected, byte actual, String message)\n"
"void assertEquals(byte expected, byte actual, Supplier<String> "
"messageSupplier)\n"
"void assertEquals(int expected, int actual)\n"
"void assertEquals(int expected, int actual, String message)\n"
"void assertEquals(int expected, int actual, Supplier<String> "
"messageSupplier)\n"
". . .\n"
"----"
msgstr ""
"Method signature is defined by its name and argument types:\n"
"[source,java]\n"
"----\n"
"//org.junit.jupiter.api.Assertions\n"
"void assertEquals(short expected, short actual)\n"
"void assertEquals(short expected, short actual, String message)\n"
"void assertEquals(short expected, short actual, Supplier<String> "
"messageSupplier)\n"
"void assertEquals(byte expected, byte actual)\n"
"void assertEquals(byte expected, byte actual, String message)\n"
"void assertEquals(byte expected, byte actual, Supplier<String> "
"messageSupplier)\n"
"void assertEquals(int expected, int actual)\n"
"void assertEquals(int expected, int actual, String message)\n"
"void assertEquals(int expected, int actual, Supplier<String> "
"messageSupplier)\n"
". . .\n"
"----"

#: lecture.adoc:492
msgid "== Статические поля и методы"
msgstr "== Static fields and methods"

#: lecture.adoc:508
msgid ""
"Данные, общие для всех экземпляров класса:\n"
"[source,java]\n"
"----\n"
"class Employee {\n"
"  /*WARNING: данный пример\n"
"  не работает при многопоточном исполнении*/\n"
"  private static int nextId = 1;\n"
"  private int id;\n"
"  . . .\n"
"  public void setId() {\n"
"    id = nextId;\n"
"    nextId++;\n"
"  }\n"
"}\n"
"----"
msgstr ""
"Data common to all instances of the class:\n"
"[source,java]\n"
"----\n"
"class Employee {\n"
"  /*WARNING: This example\n"
"  does not work in multi-threaded environment*/\n"
"  private static int nextId = 1;\n"
"  private int id;\n"
"  . . .\n"
"  public void setId() {\n"
"    id = nextId;\n"
"    nextId++;\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:511
msgid "== Статические константы"
msgstr "== Static constants"

#: lecture.adoc:520
msgid ""
"Выделяем память один раз\n"
"[source,java]\n"
"----\n"
"public class Math {\n"
"   . . .\n"
"   public static final double PI = 3.14159265358979323846;\n"
"   . . .\n"
"}"
msgstr ""
"Allocate memory once\n"
"[source,java]\n"
"----\n"
"public class Math {\n"
"   . . .\n"
"   public static final double PI = 3.14159265358979323846;\n"
"   . . .\n"
"}"

#: lecture.adoc:523
msgid ". . ."
msgstr ". . ."

#: lecture.adoc:526
msgid ""
"Math.PI // возвращает 3.14...\n"
"----"
msgstr ""
"Math.PI // returns 3.14...\n"
"----"

#: lecture.adoc:528
msgid "== Статические методы"
msgstr "== Static methods"

#: lecture.adoc:533
msgid ""
"Статическим методам доступны только статические переменные и вызовы других "
"статических методов\n"
"[source,java]\n"
"----\n"
"class Employee {"
msgstr ""
"Only static variables and other static methods are available to static "
"methods\n"
"[source,java]\n"
"----\n"
"class Employee {"

#: lecture.adoc:541
msgid ""
"  private static int nextId = 1;\n"
"  private int id;\n"
"  . . .\n"
"  public static int getNextId() {\n"
"    return nextId; // returns static field\n"
"  }\n"
"}"
msgstr ""
"  private static int nextId = 1;\n"
"  private int id;\n"
"  . . .\n"
"  public static int getNextId() {\n"
"    return nextId; // returns static field\n"
"  }\n"
"}"

#: lecture.adoc:544
msgid ""
". . .\n"
"Employee.nextId() //имя класса вместо объекта"
msgstr ""
". . .\n"
"Employee.nextId() //class name instead of object"

#: lecture.adoc:546
msgctxt "lecture.adoc:546"
msgid "----"
msgstr "----"

#: lecture.adoc:548
msgid "== psvm"
msgstr "== psvm"

#: lecture.adoc:558
msgid ""
"Теперь мы понимаем: метод main доступен всем и не требует инстанцирования "
"объекта:\n"
"[source,java]\n"
"----\n"
"public class App {\n"
"  public static void main(String... args) {\n"
"     System.out.println(\"Hello, world!\");\n"
"  }\n"
"}\n"
"----"
msgstr ""
"Now we understand: the main method is available everywhere and does not "
"require instantiation of the object:\n"
"[source,java]\n"
"----\n"
"public class App {\n"
"  public static void main(String... args) {\n"
"     System.out.println(\"Hello, world!\");\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:560
msgid "== Конструктор"
msgstr "== Constructor"

#: lecture.adoc:568
msgid ""
"[source,java]\n"
"----\n"
"public class Person {\n"
"    //public-конструктор без аргументов\n"
"    public Person() {\n"
"       ....\n"
"    }"
msgstr ""
"[source,java]\n"
"----\n"
"public class Person {\n"
"    //public constructor without arguments\n"
"    public Person() {\n"
"       ....\n"
"    }"

#: lecture.adoc:575
msgid ""
"    //package-private конструктор с аргументом\n"
"    Person(String  name) {\n"
"        ....\n"
"    }\n"
"}\n"
"----"
msgstr ""
"    //package-private constructor with argument\n"
"    Person(String name) {\n"
"        ....\n"
"    }\n"
"}\n"
"----"

#: lecture.adoc:577
msgid "== {zsp}Конструкторы{zsp}"
msgstr "== Constructors"

#: lecture.adoc:579
msgid "* Конструктор _обязан_ быть."
msgstr "* The constructor _must_ exist."

#: lecture.adoc:581
msgid ""
"* Если мы 1) явно не написали конструктор, 2) родительский класс имеет "
"конструктор без аргументов -- то неявным образом у класса появляется "
"публичный конструктор без аргументов по умолчанию."
msgstr ""
"* If we don't 1) explicitly write a constructor, 2) the parent class has a "
"constructor without arguments -- then implicitly the class will have a "
"public constructor with no default arguments."

#: lecture.adoc:583
msgid ""
"* Если мы явно написали хотя бы один конструктор,  конструктор по умолчанию "
"_исчезает_."
msgstr ""
"* If we explicitly wrote at least one constructor, the default constructor "
"_disappears_."

#: lecture.adoc:585
msgid ""
"* Если в родительском классе нет конструктора без аргументов, конструктор по "
"умолчанию _не создаётся_."
msgstr ""
"* If the parent class does not have a constructor without arguments, the "
"default constructor _is not created_."

#: lecture.adoc:587
msgid "* Конструктор _не обязан быть публичным_."
msgstr "* Constructor _does not have to be public_."

#: lecture.adoc:589
msgid "== Переопределение конструкторов при наследовании классов"
msgstr "== Overriding constructors when inheriting classes"

#: lecture.adoc:591
msgid ""
"* Если у суперкласса нет конструктора без аргументов, первым вызовом должен "
"быть `super(...)`. "
msgstr ""
"* If the superclass does not have a constructor without arguments, the first "
"call should be 'super(...) `. "

#: lecture.adoc:599
msgid ""
"[source,java]\n"
"----\n"
"public class Person {\n"
"    Person(String  name){\n"
"        ...\n"
"    }\n"
"}"
msgstr ""
"[source,java]\n"
"----\n"
"public class Person {\n"
"    Person(String  name){\n"
"        ...\n"
"    }\n"
"}"

#: lecture.adoc:607
msgid ""
"class Employee extends Person{\n"
"    Employee(String name) {\n"
"        super(name);\n"
"        ...\n"
"    }\n"
"}\n"
"----"
msgstr ""
"class Employee extends Person{\n"
"    Employee(String name) {\n"
"        super(name);\n"
"        ...\n"
"    }\n"
"}\n"
"----"

#: lecture.adoc:609
msgid "== Перегрузка конструкторов"
msgstr "== Overloading constructors"

#: lecture.adoc:611
msgid "* Вызов `this(...)`"
msgstr "* 'this(...) ` call"

#: lecture.adoc:618
msgid ""
"[source,java]\n"
"----\n"
"public class Person {\n"
"    Person(String  name){\n"
"        ...\n"
"    }"
msgstr ""
"[source,java]\n"
"----\n"
"public class Person {\n"
"    Person(String  name){\n"
"        ...\n"
"    }"

#: lecture.adoc:624
msgid ""
"    Person(){\n"
"        this(\"unknown\");\n"
"    }\n"
"}\n"
"----"
msgstr ""
"    Person(){\n"
"        this(\"unknown\");\n"
"    }\n"
"}\n"
"----"

#: lecture.adoc:631
msgid ""
"== Секции инициализации\n"
"[source,java]\n"
"----\n"
"class Employee {\n"
"  private static int nextId;\n"
"  private int id;"
msgstr ""
"== Initialization sections\n"
"[source,java]\n"
"----\n"
"class Employee {\n"
"  private static int nextId;\n"
"  private int id;"

#: lecture.adoc:636
msgid ""
"  // static initialization block\n"
"  static {\n"
"    nextId = ThreadLocalRandom.current().nextInt(10000);\n"
"  }"
msgstr ""
"  // static initialization block\n"
"  static {\n"
"    nextId = ThreadLocalRandom.current().nextInt(10000);\n"
"  }"

#: lecture.adoc:644
msgid ""
"  // object initialization block\n"
"  {\n"
"    id = nextId;\n"
"    nextId++;\n"
"  }\n"
"}\n"
"----"
msgstr ""
"  // object initialization block\n"
"  {\n"
"    id = nextId;\n"
"    nextId++;\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:646
msgid "== А как же деструктор?"
msgstr "== What about the destructor?"

#: lecture.adoc:650
msgid ""
"* А его нет!\n"
"* Даже не пытайтесь переопределять `finalize`\n"
"* Почему метод `finalize` оказался плохой идеей"
msgstr ""
"* There are no destructors!\n"
"* Don't even try to use 'finalize'\n"
"* Why the `finalize` method was a bad idea?"

#: lecture.adoc:652
msgid "== Абстрактные классы и методы"
msgstr "== Abstract classes and methods"

#: lecture.adoc:658
msgid ""
"[plantuml, abstractsample, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 120 \n"
"abstract class Person"
msgstr ""
"[plantuml, abstractsample, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 120 \n"
"abstract class Person"

#: lecture.adoc:663
msgid ""
"Person <|-- Student\n"
"Person <|-- Employee\n"
"@enduml\n"
"----"
msgstr ""
"Person <|-- Student\n"
"Person <|-- Employee\n"
"@enduml\n"
"----"

#: lecture.adoc:677
msgid ""
"[source,java]\n"
"----\n"
"public abstract class Person\n"
"{\n"
"  public Person(String name) {\n"
"    this.name = name;\n"
"  }\n"
"  public String getName() {\n"
"    return name;\n"
"  }\n"
"  public abstract String getDescription();\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"public abstract class Person\n"
"{\n"
"  public Person(String name) {\n"
"    this.name = name;\n"
"  }\n"
"  public String getName() {\n"
"    return name;\n"
"  }\n"
"  public abstract String getDescription();\n"
"}\n"
"----"

#: lecture.adoc:694
msgid ""
"== Реализация абстрактного класса\n"
"[source,java]\n"
"----\n"
"public class Student extends Person\n"
"{\n"
"  private String major;\n"
"  public Student(String name, String major) {\n"
"    super(name);\n"
"    this.major = major;\n"
"  }\n"
"  @Override\n"
"  public String getDescription() {\n"
"    return \"a student majoring in \" + major;\n"
"  }\n"
"}\n"
"----"
msgstr ""
"== Abstract class implementation\n"
"[source,java]\n"
"----\n"
"public class Student extends Person\n"
"{\n"
"  private String major;\n"
"  public Student(String name, String major) {\n"
"    super(name);\n"
"    this.major = major;\n"
"  }\n"
"  @Override\n"
"  public String getDescription() {\n"
"    return \"a student majoring in \" + major;\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:696
msgid "== Правила"
msgstr "== Rules"

#: lecture.adoc:703
msgid ""
"* Класс, в котором хотя бы один из методов не реализован, должен быть "
"помечен как `abstract`\n"
"* Нереализованные методы в классе возникают двумя способами:\n"
"** явно объявлены как `abstract`\n"
"** унаследованы из абстрактных классов или интерфейсов и не переопределены.\n"
"* Абстрактные классы нельзя инстанцировать через new.\n"
"** `new Person(\"John Doe\");` -- ошибка компиляции: 'Person is abstract, "
"cannot be instantiated'."
msgstr ""
"* A class in which at least one of the methods is not implemented must be "
"marked as `abstract`\n"
"* Unimplemented methods in a class occur in two ways:\n"
"** explicitly declared as `abstract`\n"
"** Inherited from abstract classes or interfaces and not overridden.\n"
"* Abstract classes cannot be instantiated through `new` operator.\n"
"** `new Person('John Doe');` -- compilation error: 'Person is abstract, "
"cannot be instantiated'."

#: lecture.adoc:706
msgid "== Интерфейсы"
msgstr "== Interfaces"

#: lecture.adoc:714
msgid ""
"[source,java]\n"
"----\n"
"//его нельзя инстацировать!\n"
"public interface Prism\n"
"{\n"
"   //это --- final-переменная!\n"
"   double PI = 3.14;"
msgstr ""
"[source,java]\n"
"----\n"
"// it can't be instantiated!\n"
"public interface Prism\n"
"{\n"
"   // it's a constant!\n"
"   double PI = 3.14;"

#: lecture.adoc:718
msgid ""
"   //это --- публичные абстрактные методы!\n"
"   double getArea();\n"
"   double getHeight();"
msgstr ""
"   //these are public abstract methods!\n"
"   double getArea();\n"
"   double getHeight();"

#: lecture.adoc:725
msgid ""
"   //этот метод может вызывать другие и читать final-поля\n"
"   default double getVolume() {\n"
"      return getArea() * getHeight();\n"
"   }\n"
"}\n"
"----"
msgstr ""
"   //this method can call other methods and read constants\n"
"   default double getVolume() {\n"
"      return getArea() * getHeight();\n"
"   }\n"
"}\n"
"----"

#: lecture.adoc:727
msgid "== Реализация интерфейса"
msgstr "== Interface implementation"

#: lecture.adoc:738
msgid ""
"[source,java]\n"
"----\n"
"puplic class Parallelepiped implements Prism {\n"
"    private double a;\n"
"    private double b;\n"
"    private double h;\n"
"    @Override\n"
"    public double getArea() {\n"
"        return a * b;\n"
"    }"
msgstr ""
"[source,java]\n"
"----\n"
"puplic class Parallelepiped implements Prism {\n"
"    private double a;\n"
"    private double b;\n"
"    private double h;\n"
"    @Override\n"
"    public double getArea() {\n"
"        return a * b;\n"
"    }"

#: lecture.adoc:746
msgid ""
"    @Override\n"
"    public double getHeight() {\n"
"        return h;\n"
"    }\n"
"}\n"
"----\n"
"Если какой-то из методов интерфейса не будет переопределён, класс нужно "
"пометить как abstract."
msgstr ""
"    @Override\n"
"    public double getHeight() {\n"
"        return h;\n"
"    }\n"
"}\n"
"----\n"
"If any of the interface methods are not overridden, the class should be "
"marked as abstract."

#: lecture.adoc:748
msgid "== Чем интерфейсы отличаются от абстрактных классов?"
msgstr "== How are interfaces different from abstract classes?"

#: lecture.adoc:752
msgid ""
"* Нет внутреннего состояния и конструкторов\n"
"* Можно наследоваться (`extends`) только от одного класса, но реализовывать "
"(`implements`) сколько угодно интерфейсов -- _множественное наследование_.\n"
"* Поэтому как абстракция, интерфейс предпочтительнее."
msgstr ""
"* No internal state and designers\n"
"* You can inherit (via `extends`) from only one class, but implement (via "
"`implements`) as many interfaces as you want -- _multiple inheritance_.\n"
"* Therefore, as an abstraction, the interface is preferred."

#: lecture.adoc:755
msgid "== Оператор instanceof"
msgstr "== `instanceof` operator"

#: lecture.adoc:771
msgid ""
"[plantuml, instanceof, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 150 \n"
"class C1\n"
"class C2\n"
"class C3\n"
"interface I1\n"
"C1 <|-- C2\n"
"I1 <|.. C2\n"
"@enduml\n"
"----\n"
"[source,java]\n"
"----\n"
"C1 c1; C2 c2; C3 c3; I1 i1;"
msgstr ""
"[plantuml, instanceof, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 150 \n"
"class C1\n"
"class C2\n"
"class C3\n"
"interface I1\n"
"C1 <|-- C2\n"
"I1 <|.. C2\n"
"@enduml\n"
"----\n"
"[source,java]\n"
"----\n"
"C1 c1; C2 c2; C3 c3; I1 i1;"

#: lecture.adoc:778
msgid ""
"x instanceof A //  false, если x == null\n"
"c1 instanceof С2 // true или false\n"
"i1 instanceof C2 // true или false \n"
"c2 instanceof C1 // всегда возвращает true\n"
"с3 instanceof C2 // не скомпилируется\n"
"----"
msgstr ""
"x instanceof A // false if x == null\n"
"c1 instanceof C2 // true or false\n"
"i1 instanceof C2 // true or false \n"
"c2 instanceof C1 // always returns true\n"
"c3 instanceof C2 // won't compile\n"
"----"

#: lecture.adoc:780
msgid "== Приведение типов (до Java 14)"
msgstr "== Type casting (up to Java 14)"

#: lecture.adoc:791
msgid ""
"[source,java]\n"
"----\n"
"Person p = . . .;\n"
"if (p instanceof Student) {\n"
"    //если не защитить instanceof, возможен ClassCastException\n"
"    Student s = (Student) p;\n"
"    . . .\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"Person p = . . .;\n"
"if (p instanceof Student) {\n"
"    //if you do not protect with instanceof, ClassCastException is possible\n"
"    Student s = (Student) p;\n"
"    . . .\n"
"}\n"
"----"

#: lecture.adoc:793
msgid "== Pattern Matching for instanceof (Java 14+, JEP305)"
msgstr "== Pattern Matching for instanceof (Java 14+, JEP305)"

#: lecture.adoc:804
msgid ""
"[source,java]\n"
"----\n"
"Person p = . . .;\n"
"if (p instanceof Student s) {\n"
"   //здесь доступна переменная Student s\n"
"    . . .\n"
"} else {\n"
"   //здесь недоступна переменная Student s\n"
"}"
msgstr ""
"[source,java]\n"
"----\n"
"Person p = . . .;\n"
"if (p instanceof Student s) {\n"
"   //the Student s variable is visible here\n"
"    . . .\n"
"} else {\n"
"   //the Student s variable is NOT visible here\n"
"}"

#: lecture.adoc:810
msgid ""
"//Скомпилируется\n"
"if (obj instanceof String s && s.length() > 5) { \n"
"   . . .\n"
"   s.contains(..)\n"
"}"
msgstr ""
"//Will compile\n"
"if (obj instanceof String s && s.length() > 5) { \n"
"   . . .\n"
"   s.contains(..)\n"
"}"

#: lecture.adoc:814
msgid ""
"//НЕ скомпилируется\n"
"if (obj instanceof String s || s.length() > 5) {...}\n"
"----"
msgstr ""
"//Won't compile\n"
"if (obj instanceof String s || s.length() > 5) {...}\n"
"----"

#: lecture.adoc:816
msgid "== Все меньше избыточного кода"
msgstr "== Less and less redundant code"

#: lecture.adoc:824
msgid ""
"[source,java]\n"
"----\n"
"//Before Java 10\n"
"if (obj instanceof Number) {\n"
"  Number n = (Number) obj;\n"
"  System.out.println(n.longValue());\n"
"}"
msgstr ""
"[source,java]\n"
"----\n"
"//Before Java 10\n"
"if (obj instanceof Number) {\n"
"  Number n = (Number) obj;\n"
"  System.out.println(n.longValue());\n"
"}"

#: lecture.adoc:830
msgid ""
"//Java 10+\n"
"if (obj instanceof Number) {\n"
"  var n = (Number) obj;\n"
"  System.out.println(n.longValue());\n"
"}"
msgstr ""
"//Java 10+\n"
"if (obj instanceof Number) {\n"
"  var n = (Number) obj;\n"
"  System.out.println(n.longValue());\n"
"}"

#: lecture.adoc:836
msgid ""
"//Java 14+\n"
"if (obj instanceof Number n) {\n"
"  System.out.println(n.longValue());\n"
"}\n"
"----"
msgstr ""
"//Java 14+\n"
"if (obj instanceof Number n) {\n"
"  System.out.println(n.longValue());\n"
"}\n"
"----"

#: lecture.adoc:838
msgid "== Pattern matching for switch (JEP406, preview feature in Java 17)"
msgstr "== Pattern matching for switch (JEP406, preview feature in Java 17)"

#: lecture.adoc:852
msgid ""
"[source,java]\n"
"----\n"
"public int calculate(Expr expr) {\n"
"  return switch (expr) {\n"
"    //Не скомпилируется, если мы забудем что-то из реализаций Expr!\n"
"    case Literal l -> l.value();\n"
"    case Divide d -> calculate(d.left()) / calculate(d.right());\n"
"    case Multiply m -> calculate(m.left()) * calculate(m.right());\n"
"    case Add a -> calculate(a.left()) + calculate(a.right());\n"
"    case Subtract s -> calculate(s.left()) - calculate(s.right());\n"
"  };\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"public int calculate(Expr expr) {\n"
"  return switch (expr) {\n"
"    //Won't comile if we forgot some of the Expr implementations!\n"
"    case Literal l -> l.value();\n"
"    case Divide d -> calculate(d.left()) / calculate(d.right());\n"
"    case Multiply m -> calculate(m.left()) * calculate(m.right());\n"
"    case Add a -> calculate(a.left()) + calculate(a.right());\n"
"    case Subtract s -> calculate(s.left()) - calculate(s.right());\n"
"  };\n"
"}\n"
"----"

#: lecture.adoc:854
msgctxt "lecture.adoc:854"
msgid "== Вложенные классы"
msgstr "== Nested classes"

#: lecture.adoc:871
msgid ""
"[source, java]\n"
"----\n"
"class Outer { \n"
"   int field = 42; \n"
"   class Inner { \n"
"      public void show() { \n"
"           //есть доступ к состоянию внешнего класса!\n"
"           System.out.println(field);\n"
"           //печатает 42\n"
"      } \n"
"   } \n"
"   void initInner(){\n"
"     //инициализация вложенного класса внутри\n"
"     new Inner();\n"
"   }\n"
"} "
msgstr ""
"[source, java]\n"
"----\n"
"class Outer { \n"
"   int field = 42; \n"
"   class Inner { \n"
"      public void show() { \n"
"           //there is an access to the external class's state!\n"
"           System.out.println(field);\n"
"           //prints 42\n"
"      } \n"
"   } \n"
"   void initInner(){\n"
"     // initialization of the nested class inside the outer class\n"
"     new Inner();\n"
"   }\n"
"} "

#: lecture.adoc:875
msgid ""
"//инициализация вложенного класса извне\n"
"Outer.Inner in = new Outer().new Inner(); \n"
"----"
msgstr ""
"//initialization of a nested outside the outer class\n"
"Outer.Inner in = new Outer().new Inner(); \n"
"----"

#: lecture.adoc:877
msgctxt "lecture.adoc:877"
msgid "== Вложенные классы"
msgstr "== Nested classes"

#: lecture.adoc:879
msgid "Каждый экземпляр `Inner` имеет неявную ссылку на `Outer`."
msgstr "Each instance of `Inner` has an implicit reference to `Outer`."

#: lecture.adoc:889
msgid ""
"[plantuml, inner, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 200 \n"
"class Outer\n"
"class Inner\n"
"Outer *-- Inner\n"
"@enduml\n"
"----"
msgstr ""
"[plantuml, inner, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 200 \n"
"class Outer\n"
"class Inner\n"
"Outer *-- Inner\n"
"@enduml\n"
"----"

#: lecture.adoc:891
msgctxt "lecture.adoc:891"
msgid "== Вложенные классы"
msgstr "== Nested classes"

#: lecture.adoc:906
msgid ""
"[source, java]\n"
"----\n"
"class Outer { \n"
"   int field = 42; \n"
"   class Inner { \n"
"      //поле вложенного класса перекрывает поле внешнего класса \n"
"      int field = 18;\n"
"      public void show() {\n"
"           System.out.println(field);\n"
"           //печатает 18\n"
"      } \n"
"   } \n"
"} \n"
"----"
msgstr ""
"[source, java]\n"
"----\n"
"class Outer { \n"
"   int field = 42; \n"
"   class Inner { \n"
"      //nested class field hides external class field \n"
"      int field = 18;\n"
"      public void show() {\n"
"           System.out.println(field);\n"
"           //prints 18\n"
"      } \n"
"   } \n"
"} \n"
"----"

#: lecture.adoc:908
msgctxt "lecture.adoc:908"
msgid "== Вложенные классы"
msgstr "== Nested classes"

#: lecture.adoc:923
msgid ""
"[source, java]\n"
"----\n"
"class Outer { \n"
"   int field = 42; \n"
"   class Inner { \n"
"      //поле вложенного класса перекрывает поле внешнего класса \n"
"      int field = 18;\n"
"      public void show() {\n"
"           System.out.println(Outer.this.field);\n"
"           //печатает 42!\n"
"      } \n"
"   } \n"
"} \n"
"----"
msgstr ""
"[source, java]\n"
"----\n"
"class Outer { \n"
"   int field = 42; \n"
"   class Inner { \n"
"      //nested class field hides external class field  \n"
"      int field = 18;\n"
"      public void show() {\n"
"           System.out.println(Outer.this.field);\n"
"           //prints 42!\n"
"      } \n"
"   } \n"
"} \n"
"----"

#: lecture.adoc:925
msgid "== Локальные вложенные классы"
msgstr "== Local nested classes"

#: lecture.adoc:943
msgid ""
"[source,java]\n"
"----\n"
"class Outer { \n"
"   void outerMethod() { \n"
"      //final (или effectively final) тут существенно\n"
"      final int x = 98; \n"
"      System.out.println(\"inside outerMethod\"); \n"
"      class Inner { \n"
"         void innerMethod() { \n"
"            System.out.println(\"x = \" + x); \n"
"         } \n"
"      } \n"
"      Inner y = new Inner(); \n"
"      y.innerMethod(); \n"
"   } \n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"class Outer { \n"
"   void outerMethod() { \n"
"      //final (or effectively final) here matters!\n"
"      final int x = 98; \n"
"      System.out.println(\"inside outerMethod\"); \n"
"      class Inner { \n"
"         void innerMethod() { \n"
"            System.out.println(\"x = \" + x); \n"
"         } \n"
"      } \n"
"      Inner y = new Inner(); \n"
"      y.innerMethod(); \n"
"   } \n"
"}\n"
"----"

#: lecture.adoc:945
msgid "== Java 15: локальные record-ы, enum-ы и интерфейсы"
msgstr "== Java 15: local records, enums and interfaces"

#: lecture.adoc:954
msgid ""
"[source,java]\n"
"----\n"
"class Outer { \n"
"   void outerMethod() { \n"
"      //они не захватывают внешнее состояние\n"
"      record Foo (int a, int b) {};\n"
"      enum Bar {A, B};\n"
"      interface Baz {};"
msgstr ""
"[source,java]\n"
"----\n"
"class Outer { \n"
"   void outerMethod() { \n"
"      //they do not capture the external state\n"
"      record Foo (int a, int b) {};\n"
"      enum Bar {A, B};\n"
"      interface Baz {};"

#: lecture.adoc:961
msgid ""
"      //NB:\n"
"      //static not allowed here!\n"
"      static class X {};\n"
"   } \n"
"}\n"
"----"
msgstr ""
"      //NB:\n"
"      //static not allowed here!\n"
"      static class X {};\n"
"   } \n"
"}\n"
"----"

#: lecture.adoc:964
msgid "== Вложенные статические классы"
msgstr "== Nested static classes"

#: lecture.adoc:966
msgid "По сути, ничем не отличаются от просто классов:"
msgstr "In fact, they are no different from just classes:"

#: lecture.adoc:984
msgid ""
"[source,java]\n"
"----\n"
"class Outer { \n"
"   private static void outerMethod() { \n"
"     System.out.println(\"inside outerMethod\"); \n"
"   } \n"
"   static class Inner { \n"
"     public static void main(String[] args) { \n"
"        System.out.println(\"inside inner class Method\"); \n"
"        outerMethod(); \n"
"     } \n"
"   }\n"
"}\n"
". . .\n"
"Outer.Inner x = new Outer.Inner();\n"
"// в отличие от не статического: new Outer().new Inner();\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"class Outer { \n"
"   private static void outerMethod() { \n"
"     System.out.println(\"inside outerMethod\"); \n"
"   } \n"
"   static class Inner { \n"
"     public static void main(String[] args) { \n"
"        System.out.println(\"inside inner class Method\"); \n"
"        outerMethod(); \n"
"     } \n"
"   }\n"
"}\n"
". . .\n"
"Outer.Inner x = new Outer.Inner();\n"
"//unlike non-static new Outer().new Inner();\n"
"----"

#: lecture.adoc:986
msgid "== Анонимные классы"
msgstr "== Anonymous classes"

#: lecture.adoc:1006
msgid ""
"[source,java]\n"
"----\n"
"class Demo {\n"
"    void show() {\n"
"        System.out.println(\"superclass\");\n"
"    }\n"
"}\n"
"class Flavor1Demo {\n"
"    public static void main(String[] args){\n"
"        Demo d = new Demo() {\n"
"            void show() {\n"
"                super.show();\n"
"                System.out.println(\"subclass\");\n"
"            }\n"
"        };\n"
"        d.show();\n"
"    }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"class Demo {\n"
"    void show() {\n"
"        System.out.println(\"superclass\");\n"
"    }\n"
"}\n"
"class Flavor1Demo {\n"
"    public static void main(String[] args){\n"
"        Demo d = new Demo() {\n"
"            void show() {\n"
"                super.show();\n"
"                System.out.println(\"subclass\");\n"
"            }\n"
"        };\n"
"        d.show();\n"
"    }\n"
"}\n"
"----"

#: lecture.adoc:1008
msgid "== Использование анонимных классов"
msgstr "== Using Anonymous Classes"

#: lecture.adoc:1011
msgid ""
"* Чаще всего -- как реализация абстрактных классов и интерфейсов «по месту»\n"
"* Анонимный класс -- вложенный класс, поэтому до появления лямбд и ссылок на "
"методы это был единственный способ организовать коллбэк"
msgstr ""
"* Most often - as an implementation of abstract classes and interfaces \"in "
"place\"\n"
"* An anonymous class is a nested class, so before the introduction of "
"lambdas and method references, this was the only way to organize a callback"

#: lecture.adoc:1021
msgid ""
"[source,java]\n"
"----\n"
". . . \n"
"button.onMouseClick(new EventListener(){\n"
"  void onClick(Event e) {\n"
"     //здесь у нас доступ ко всем внешним полям\n"
"     //и effectively final-переменным \n"
"  }\n"
"});"
msgstr ""
"[source,java]\n"
"----\n"
". . . \n"
"button.onMouseClick(new EventListener(){\n"
"  void onClick(Event e) {\n"
"     //here we have access to all external fields\n"
"     //and effectively final-variables \n"
"  }\n"
"});"

#: lecture.adoc:1023
msgctxt "lecture.adoc:1023"
msgid "----"
msgstr "----"

#: lecture.adoc:1025
msgid "== Object: the Cosmic Superclass"
msgstr "== Object: the Cosmic Superclass"

#: lecture.adoc:1031
msgid ""
"* Любой класс в Java является наследником `Object`\n"
"* Писать `class Employee extends Object` не надо\n"
"* В этом классе определены важные методы\n"
"** `equals` и `hashCode`\n"
"** `toString`"
msgstr ""
"* Any class in Java is a descendant of 'Object'\n"
"* You don't need to write `class Employee extends Object`\n"
"* Important methods are defined in this class\n"
"** `equals` and `hashCode`\n"
"** `toString`"

#: lecture.adoc:1033
msgid "== `equals()` и `hashCode()`"
msgstr "== `equals()` and `hashCode()`"

#: lecture.adoc:1037
msgid ""
"* `boolean equals(Object other)` возвращает `true` т. и т. т., когда "
"внутреннее состояние совпадает\n"
"* `int hashCode()` возвращает целое значение, которое обязано совпадать для "
"объектов с одинаковым внутренним состоянием\n"
"* Это нужно для хеш-таблиц (и, пожалуй, является __протекшей абстракцией__)"
msgstr ""
"* `boolean equals(Object other)` returns `true` iff the internal states "
"coincide\n"
"* `int hashCode()` returns an integer value that must match for objects with "
"the same internal state\n"
"* This is needed for hash tables (and probably is __a leaky abstraction__)"

#: lecture.adoc:1039
msgid "== Формальный контракт `equals`"
msgstr "== `equals` formal contract"

#: lecture.adoc:1048
msgid ""
"1. Рефлексивность: +\n"
"stem:[\\forall x \\ne \\mathrm{null} (x.equals(x))]\n"
"2. Симметричность: +\n"
"stem:[\\forall x \\ne \\mathrm{null} \\, \\forall y \\ne \\mathrm{null} (x."
"equals(y) \\iff y.equals(x))]\n"
"3. Транзитивность: +\n"
"stem:[\\forall x \\ne \\mathrm{null} \\, \\forall y \\ne \\mathrm{null} \\, "
"\\forall z \\ne \\mathrm{null} (x.equals(y) \\& y.equals(z) \\Rightarrow x."
"equals(z))]\n"
"4. Консистентность: если сравниваемые объекты не изменялись, повторный вызов "
"`equals` должен возвращать одно и то же значение.\n"
"5. stem:[\\forall x \\ne \\mathrm{null} (x.equals(\\mathrm{null}) = "
"\\mathrm{false})]"
msgstr ""
"1. Reflexivity: +\n"
"stem:[\\forall x \\ne \\mathrm{null} (x.equals(x))]\n"
"2. Symmetry: +\n"
"stem:[\\forall x \\ne \\mathrm{null} \\, \\forall y \\ne \\mathrm{null} (x."
"equals(y) \\iff y.equals(x))]\n"
"3. Transitivity: +\n"
"stem:[\\forall x \\ne \\mathrm{null} \\, \\forall y \\ne \\mathrm{null} \\, "
"\\forall z \\ne \\mathrm{null} (x.equals(y) \\& y.equals(z) \\Rightarrow x."
"equals(z))]\n"
"4. Consistency: if compared objects didn't change, each `equals` invocation "
"must return the same value.\n"
"5. stem:[\\forall x \\ne \\mathrm{null} (x.equals(\\mathrm{null}) = "
"\\mathrm{false})]"

#: lecture.adoc:1050
msgid "== Формальный контракт `hashCode`"
msgstr "== `hashCode` formal contract"

#: lecture.adoc:1057
msgid ""
"1. Консистентность: если объект не изменялся, повторный вызов `hashCode` "
"должен возвращать одно и то же значение (но не обязательно одно и то же "
"между разными запусками приложения)\n"
"2. Связь с `equals`: +\n"
"stem:[\\forall x \\forall y (x.equals(y) \\Rightarrow x.hashCode() = y."
"hashCode())]\n"
"3. Хотя +\n"
"stem:[x.hashCode() = y.hashCode() \\Rightarrow x.equals(y)] +\n"
"и не обязательно, но желательно для большинства случаев."
msgstr ""
"1. Consistency: if compared objects didn't change, each `hashCode()` "
"invocation must return the same value (but not necessary the same between "
"different runs of the application)\n"
"2. Relation to `equals`: +\n"
"stem:[\\forall x \\forall y (x.equals(y) \\Rightarrow x.hashCode() = y."
"hashCode())]\n"
"3. While+\n"
"stem:[x.hashCode() = y.hashCode() \\Rightarrow x.equals(y)] +\n"
"is not obligatory, but it's desirable for most of the cases."

#: lecture.adoc:1059
msgid "== Выводы"
msgstr "== Conclusions"

#: lecture.adoc:1064
msgid ""
"1. Переопределять `equals` и `hashCode` нужно только вместе и согласованно, "
"чтобы выполнить контракт stem:[x.equals(y) \\Rightarrow x.hashCode() = y."
"hashCode()]\n"
"2. Грамотно реализовать `equals` и `hashCode` трудно, но, к счастью, "
"самостоятельно это делать не нужно.\n"
"3. Для тестирования есть специальная библиотка https://jqno.nl/"
"equalsverifier/[EqualsVerifier].\n"
"4. Для генерации `equals` и `hashCode` можно использовать возможности IDE "
"или библиотеки https://projectlombok.org/[Lombok]."
msgstr ""
"1. `equals` and `hashCode` should be overridden together and consistently to "
"fulfil the contract stem:[x.equals(y) \\Rightarrow x.hashCode() = y."
"hashCode()]\n"
"2. It is difficult to properly implement `equals` and `hashCode`, but, "
"fortunately, you do not need to do it yourself.\n"
"3. For testing there is a special library https://jqno.nl/equalsverifier/"
"[EqualsVerifier].\n"
"4. To generate `equals` and `hashCode` you can either use the capabilities "
"of the IDE or https://projectlombok.org/[Lombok] library."

#: lecture.adoc:1066
msgctxt "lecture.adoc:1066"
msgid "== Генерация `equals` и `hashCode`"
msgstr "== Code generation of 'equals' and 'hashCode'"

#: lecture.adoc:1068
msgid "image::generateequals.png[{image-50-width}]"
msgstr "image::generateequals.png[{image-50-width}]"

#: lecture.adoc:1070
msgctxt "lecture.adoc:1070"
msgid "== Генерация `equals` и `hashCode`"
msgstr "== Code generation of 'equals' and 'hashCode'"

#: lecture.adoc:1085
msgid ""
"[source,java]\n"
"----\n"
"public class Person {\n"
"    private String name;\n"
"    private int age;\n"
"    @Override\n"
"    public boolean equals(Object o) {\n"
"       // никогда, НИКОГДА не пишите это сами\n"
"        if (this == o) return true;\n"
"        if (o == null || getClass() != o.getClass()) return false;\n"
"        Person person = (Person) o;\n"
"        return age == person.age &&\n"
"                Objects.equals(name, person.name);\n"
"    }"
msgstr ""
"[source,java]\n"
"----\n"
"public class Person {\n"
"    private String name;\n"
"    private int age;\n"
"    @Override\n"
"    public boolean equals(Object o) {\n"
"       // NEVER EVER write this yourself!\n"
"        if (this == o) return true;\n"
"        if (o == null || getClass() != o.getClass()) return false;\n"
"        Person person = (Person) o;\n"
"        return age == person.age &&\n"
"                Objects.equals(name, person.name);\n"
"    }"

#: lecture.adoc:1092
msgid ""
"    @Override\n"
"    public int hashCode() {\n"
"        return Objects.hash(name, age);\n"
"    }\n"
"}\n"
"----"
msgstr ""
"    @Override\n"
"    public int hashCode() {\n"
"        return Objects.hash(name, age);\n"
"    }\n"
"}\n"
"----"

#: lecture.adoc:1094
msgctxt "lecture.adoc:1094"
msgid "== Или, если у нас Lombok"
msgstr "== Or if we have Lombok"

#: lecture.adoc:1098
msgid ""
"[source,java]\n"
"----\n"
"import lombok.EqualsAndHashCode;"
msgstr ""
"[source,java]\n"
"----\n"
"import lombok.EqualsAndHashCode;"

#: lecture.adoc:1105
msgid ""
"@EqualsAndHashCode\n"
"public class Person {\n"
"    private  int age;\n"
"    private  String name;\n"
"}\n"
"----"
msgstr ""
"@EqualsAndHashCode\n"
"public class Person {\n"
"    private  int age;\n"
"    private  String name;\n"
"}\n"
"----"

#: lecture.adoc:1108
msgid "== Переопределение toString"
msgstr "== Overriding `toString`"

#: lecture.adoc:1127
msgid ""
"[source,java]\n"
"----\n"
"public class Person {\n"
"    private String name;\n"
"    private int age;\n"
"    . . .\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Person{\" +\n"
"                \"name='\" + name + '\\'' +\n"
"                \", age=\" + age +\n"
"                '}';\n"
"    }\n"
"}\n"
". . .\n"
"Person person = . . .\n"
"System.out.println(person);\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"public class Person {\n"
"    private String name;\n"
"    private int age;\n"
"    . . .\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Person{\" +\n"
"                \"name='\" + name + '\\'' +\n"
"                \", age=\" + age +\n"
"                '}';\n"
"    }\n"
"}\n"
". . .\n"
"Person person = . . .\n"
"System.out.println(person);\n"
"----"

#: lecture.adoc:1129
msgctxt "lecture.adoc:1129"
msgid "== Или, если у нас Lombok"
msgstr "== Or if we have Lombok"

#: lecture.adoc:1133
msgid ""
"[source,java]\n"
"----\n"
"import lombok.ToString;"
msgstr ""
"[source,java]\n"
"----\n"
"import lombok.ToString;"

#: lecture.adoc:1140
msgid ""
"@ToString\n"
"public class Person {\n"
"    private  int age;\n"
"    private  String name;\n"
"}\n"
"----"
msgstr ""
"@ToString\n"
"public class Person {\n"
"    private  int age;\n"
"    private  String name;\n"
"}\n"
"----"

#: lecture.adoc:1142
msgid "== Полный «обвес» класса"
msgstr "== Full boilerplaite of the class"

#: lecture.adoc:1148
msgid ""
"[source,java]\n"
"----\n"
"public class Point {\n"
"  private final int x;\n"
"  private final int y;"
msgstr ""
"[source,java]\n"
"----\n"
"public class Point {\n"
"  private final int x;\n"
"  private final int y;"

#: lecture.adoc:1156
msgid ""
"  /*Подождите! Нам нужны:\n"
"   * конструктор\n"
"   * getX() и getY()\n"
"   * equals и hashCode\n"
"   * toString\n"
"   * 40 строчек кода из ничего!\n"
"   */"
msgstr ""
"  /*Oh wait! We need:\n"
"   * constructor\n"
"   * getX() and getY()\n"
"   * equals and hashCode\n"
"   * toString\n"
"   * 40 lines of code for nothing!\n"
"   */"

#: lecture.adoc:1162
msgid ""
"  public double distance(Point other) {\n"
"    ...\n"
"  }\n"
"}\n"
"----"
msgstr ""
"  public double distance(Point other) {\n"
"    ...\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:1165
msgctxt "lecture.adoc:1165"
msgid "== Или, если у нас Lombok"
msgstr "== Or if we have Lombok"

#: lecture.adoc:1169
msgid ""
"[source,java]\n"
"----\n"
"import lombok.Data;"
msgstr ""
"[source,java]\n"
"----\n"
"import lombok.Data;"

#: lecture.adoc:1179
msgid ""
"@Data\n"
"public class Point {\n"
"  private final int x;\n"
"  private final int y;\n"
"  public double distance(Point other) {\n"
"    ...\n"
"  }\n"
"}\n"
"----"
msgstr ""
"@Data\n"
"public class Point {\n"
"  private final int x;\n"
"  private final int y;\n"
"  public double distance(Point other) {\n"
"    ...\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:1181
msgid "== Или, если у нас Java 14+"
msgstr "== Or if we have Java 14+"

#: lecture.adoc:1190
msgid ""
"[source,java]\n"
"----\n"
"record Point(int x, int y) { \n"
"  public double distance(Point other) {\n"
"    ...\n"
"  }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"record Point(int x, int y) { \n"
"  public double distance(Point other) {\n"
"    ...\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:1195
msgid ""
"* `private final` поля\n"
"* конструктор\n"
"* доступ через `x()` и `y()`\n"
"* `equals`, `hashCode` и `toString`\n"
"* невозможно наследование от класса и от рекорда, но возможна реализация "
"интерфейсов"
msgstr ""
"* `private final` fields\n"
"* constructor\n"
"* access using `x()` and `y()`\n"
"* `equals`, `hashCode` and `toString`\n"
"* one can't inherit a record from a class or a record, but can implement "
"interfaces"

#~ msgid ""
#~ "//== Часть 1. Введение\n"
#~ ":!figure-caption:"
#~ msgstr ""
#~ "//== Part 1. Introduction\n"
#~ ":!figure-caption:"

#~ msgctxt "lecture.adoc:198"
#~ msgid "== Присвоение ссылки"
#~ msgstr "== Reference assignment"

#~ msgctxt "lecture.adoc:309"
#~ msgid "== Наследование"
#~ msgstr "== Inheritance"

#~ msgctxt "lecture.adoc:545"
#~ msgid "----"
#~ msgstr "----"

#~ msgctxt "lecture.adoc:876"
#~ msgid "== Вложенные классы"
#~ msgstr "== Nested classes"

#~ msgctxt "lecture.adoc:890"
#~ msgid "== Вложенные классы"
#~ msgstr "== Nested classes"

#~ msgctxt "lecture.adoc:907"
#~ msgid "== Вложенные классы"
#~ msgstr "== Nested classes"

#~ msgctxt "lecture.adoc:1022"
#~ msgid "----"
#~ msgstr "----"

#~ msgctxt "lecture.adoc:1069"
#~ msgid "== Генерация `equals` и `hashCode`"
#~ msgstr "== Code generation of 'equals' and 'hashCode'"

#~ msgctxt "lecture.adoc:1128"
#~ msgid "== Или, если у нас Lombok"
#~ msgstr "== Or if we have Lombok"

#~ msgctxt "lecture.adoc:1164"
#~ msgid "== Или, если у нас Lombok"
#~ msgstr "== Or if we have Lombok"

#~ msgctxt "./slides03/src/main/asciidoc/lecture.adoc:198"
#~ msgid "== Присвоение ссылки"
#~ msgstr "== Reference assignment"

#~ msgctxt "./slides03/src/main/asciidoc/lecture.adoc:309"
#~ msgid "== Наследование"
#~ msgstr "== Наследование"

#~ msgctxt "./slides03/src/main/asciidoc/lecture.adoc:545"
#~ msgid "----"
#~ msgstr "----"

#~ msgctxt "./slides03/src/main/asciidoc/lecture.adoc:876"
#~ msgid "== Вложенные классы"
#~ msgstr "== Nested classes"

#~ msgctxt "./slides03/src/main/asciidoc/lecture.adoc:890"
#~ msgid "== Вложенные классы"
#~ msgstr "== Nested classes"

#~ msgctxt "./slides03/src/main/asciidoc/lecture.adoc:907"
#~ msgid "== Вложенные классы"
#~ msgstr "== Nested classes"

#~ msgctxt "./slides03/src/main/asciidoc/lecture.adoc:1022"
#~ msgid "----"
#~ msgstr "----"

#~ msgctxt "./slides03/src/main/asciidoc/lecture.adoc:1069"
#~ msgid "== Генерация `equals` и `hashCode`"
#~ msgstr "== Code generation of 'equals' and 'hashCode'"

#~ msgctxt "./slides03/src/main/asciidoc/lecture.adoc:1128"
#~ msgid "== Или, если у нас Lombok"
#~ msgstr "== Or if we have Lombok"

#~ msgctxt "./slides03/src/main/asciidoc/lecture.adoc:1164"
#~ msgid "== Или, если у нас Lombok"
#~ msgstr "== Or if we have Lombok"
