msgid ""
msgstr ""
"Project-Id-Version: slides 10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-16 14:05+0300\n"
"PO-Revision-Date: 2022-03-05 17:47+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: en_UK\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.0.1\n"

#: lecture.adoc:25
msgid ""
"= Core Java. Лекция 10: Java Concurrency\n"
"Иван Пономарёв, КУРС/МФТИ\n"
":revealjs_theme: black\n"
":revealjs_customtheme: white_course.css\n"
":revealjs_slideNumber:\n"
":revealjs_history:\n"
":revealjs_progress:\n"
":encoding: UTF-8\n"
":lang: ru\n"
"include::_doc_general_attributes.adoc[]\n"
":doctype: article\n"
":toclevels: 3\n"
":imagesdir: images\n"
":source-highlighter: highlightjs\n"
":highlightjsdir: highlight\n"
":icons: font\n"
":iconfont-remote!:\n"
":iconfont-name: font-awesome-4.7.0/css/font-awesome\n"
":revealjs_mouseWheel: true\n"
":revealjs_center: false\n"
":revealjs_transition: none\n"
":revealjs_width: 1600\n"
":revealjs_height: 900\n"
":stem: latexmath"
msgstr ""
"= Core Java. Lecture #10: Java Concurrency\n"
"Ivan Ponomarev, Synthesized.io/MIPT\n"
":revealjs_theme: black\n"
":revealjs_customtheme: white_course.css\n"
":revealjs_slideNumber:\n"
":revealjs_history:\n"
":revealjs_progress:\n"
":encoding: UTF-8\n"
":lang: ru\n"
"include::_doc_general_attributes.adoc[]\n"
":doctype: article\n"
":toclevels: 3\n"
":imagesdir: images\n"
":source-highlighter: highlightjs\n"
":highlightjsdir: highlight\n"
":icons: font\n"
":iconfont-remote!:\n"
":iconfont-name: font-awesome-4.7.0/css/font-awesome\n"
":revealjs_mouseWheel: true\n"
":revealjs_center: false\n"
":revealjs_transition: none\n"
":revealjs_width: 1600\n"
":revealjs_height: 900\n"
":stem: latexmath"

#: lecture.adoc:29
msgid ""
"//== Часть 1. Введение\n"
":!figure-caption:"
msgstr ""
"//== Часть 1. Введение\n"
":!figure-caption:"

#: lecture.adoc:31
msgid "ponomarev@corchestra.ru"
msgstr "ponomarev@corchestra.ru"

#: lecture.adoc:33
msgid "icon:twitter[size=lg] @inponomarev"
msgstr "icon:twitter[size=lg] @inponomarev"

#: lecture.adoc:35
msgid "== Concurrency -- конкурентное выполнение"
msgstr "== Concurrent execution"

#: lecture.adoc:38
msgid ""
"* Одна программа -- много одновременно выполняющихся тредов (threads)\n"
"* Зачем нам вообще Concurrency?"
msgstr ""
"* One program -- many simultaneous threads\n"
"* Why do we need Concurrency at all?"

#: lecture.adoc:41
msgid ""
"[.fragment]\n"
"-- Для перформанса, чтобы побыстрее!"
msgstr ""
"[.fragment]\n"
"-- For performance, to make things quickly!"

#: lecture.adoc:43
msgid "== Где мы можем получить выгоду от concurrency?"
msgstr "== Where can we benefit from concurrency?"

#: lecture.adoc:48
msgid ""
"* Много CPU-ядер, вычислительная задача хорошо разделяется на подзадачи.\n"
"* Подзадачи блокируются на вводе/выводе, можно параллельно ждать других или "
"делать что-то полезное.\n"
"* Нужно быстро отреагировать на запрос, а потом дать детальный ответ "
"(пользовательский интерфейс).\n"
"* Многопользовательский сервис (каждый запрос в своём треде)."
msgstr ""
"* Many CPU cores, the computational task is divided into subtasks well.\n"
"* Subtasks are blocked on I/O, you can wait for multiple replies in parallel "
"or do something useful.\n"
"* You need to respond to the request quickly and give a detailed answer "
"later (user interface).\n"
"* Multi-user service (each request is in its own thread)."

#: lecture.adoc:51
msgid "== Где мы НЕ можем получить выгоду от [увеличения] concurrency?"
msgstr "== Where can we NOT benefit from [increasing] concurrency?"

#: lecture.adoc:55
msgid ""
"* CPU-bound задача не будет решаться быстрее, если тредов больше, чем ядер.\n"
"* Задача плохо параллелизуется (упирается в неразделяемый ресурс).\n"
"* Нас ограничивает закон Амдала."
msgstr ""
"* CPU-bound task will not be solved faster if there are more threads than "
"cores.\n"
"* The task is poorly parallelized (limited by a non-divisible resource).\n"
"* We are limited by Amdahl law."

#: lecture.adoc:57
msgid "== Закон Амдала (Amdahl's law)"
msgstr "== Amdahl's law"

#: lecture.adoc:61
msgid ""
"* &alpha; -- доля вычислений, которая должна выполняться последовательно,\n"
"* _N_ -- число параллельных потоков выполнения,\n"
"* _S_ -- полученное ускорение (speedup)."
msgstr ""
"* &alpha; is the proportion of calculations that must be performed "
"sequentially,\n"
"* _N_ -- number of simultaneously executed threads,\n"
"* _S_ -- the resulting speedup."

#: lecture.adoc:67
msgid ""
"[stem] \n"
"++++\n"
"\\Huge\n"
"S = \\frac{1}{\\alpha+\\frac{1-\\alpha}{N}} = \\frac{N}{1+\\alpha(N-1)} "
"\\leq \\frac{1}{\\alpha}\n"
"++++"
msgstr ""
"[stem] \n"
"++++\n"
"\\Huge\n"
"S = \\frac{1}{\\alpha+\\frac{1-\\alpha}{N}} = \\frac{N}{1+\\alpha(N-1)} "
"\\leq \\frac{1}{\\alpha}\n"
"++++"

#: lecture.adoc:69
msgid ""
"Вывод: если разделяемая работа составляет 80%, вы не получите более чем "
"пятикратное увеличение производительности за счёт параллелизации."
msgstr ""
"Bottom line: If the shared work is 80%, you won't get more than a fivefold "
"increase in performance due to parallelization."

#: lecture.adoc:71
msgid "== Закон Амдала: поведение"
msgstr "== Amdahl's Law"

#: lecture.adoc:73
msgid "image::amdahl.png[{image-70-width}]"
msgstr "image::amdahl.png[{image-70-width}]"

#: lecture.adoc:75
msgctxt "lecture.adoc:75"
msgid "== На самом деле, всё ещё хуже! "
msgstr "== In fact, it's even worse! "

#: lecture.adoc:102
msgid ""
"[cols=\"25a,25a,25a,25a\"]\n"
"|===\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 4, E = 6\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 5, E = 10\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 6, E = 15\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 7, E = 21\n"
"++++"
msgstr ""
"[cols=\"25a,25a,25a,25a\"]\n"
"|===\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 4, E = 6\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 5, E = 10\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 6, E = 15\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 7, E = 21\n"
"++++"

#: lecture.adoc:115
msgid ""
"^.^|\n"
"[graphviz,\"k4.png\"]\n"
"----\n"
"graph K4 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d;\n"
"    b--c; b--d;\n"
"    c--d;\n"
"}\n"
"----"
msgstr ""
"^.^|\n"
"[graphviz,\"k4.png\"]\n"
"----\n"
"graph K4 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d;\n"
"    b--c; b--d;\n"
"    c--d;\n"
"}\n"
"----"

#: lecture.adoc:117
msgctxt "lecture.adoc:117"
msgid "^.^|"
msgstr "^.^|"

#: lecture.adoc:130
msgid ""
"[graphviz,\"k5.png\"]\n"
"----\n"
"graph K5 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e;\n"
"    b--c; b--d; b--e;\n"
"    c--d; c--e;\n"
"    d--e;\n"
"}\n"
"----"
msgstr ""
"[graphviz,\"k5.png\"]\n"
"----\n"
"graph K5 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e;\n"
"    b--c; b--d; b--e;\n"
"    c--d; c--e;\n"
"    d--e;\n"
"}\n"
"----"

#: lecture.adoc:132
msgctxt "lecture.adoc:132"
msgid "^.^|"
msgstr "^.^|"

#: lecture.adoc:145
msgid ""
"[graphviz,\"k6.png\"]\n"
"----\n"
"graph K6 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e; a--f;\n"
"    b--c; b--d; b--e; b--f;\n"
"    c--d; c--e; c--f;\n"
"    d--e; d--f;\n"
"    e--f;\n"
"}"
msgstr ""
"[graphviz,\"k6.png\"]\n"
"----\n"
"graph K6 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e; a--f;\n"
"    b--c; b--d; b--e; b--f;\n"
"    c--d; c--e; c--f;\n"
"    d--e; d--f;\n"
"    e--f;\n"
"}"

#: lecture.adoc:148
msgctxt "lecture.adoc:148"
msgid "^.^|"
msgstr "^.^|"

#: lecture.adoc:164
msgid ""
"[graphviz,\"k7.png\"]\n"
"----\n"
"graph K7 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e; a--f; a--g;\n"
"    b--c; b--d; b--e; b--f; b--g;\n"
"    c--d; c--e; c--f; c--g;\n"
"    d--e; d--f; d--g;\n"
"    e--f; e--g;\n"
"    f--g;\n"
"}\n"
"----\n"
"|==="
msgstr ""
"[graphviz,\"k7.png\"]\n"
"----\n"
"graph K7 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e; a--f; a--g;\n"
"    b--c; b--d; b--e; b--f; b--g;\n"
"    c--d; c--e; c--f; c--g;\n"
"    d--e; d--f; d--g;\n"
"    e--f; e--g;\n"
"    f--g;\n"
"}\n"
"----\n"
"|==="

#: lecture.adoc:170
msgid ""
"[stem] \n"
"++++\n"
"\\Huge\n"
"E = \\frac{N (N -1)}{2}\n"
"++++"
msgstr ""
"[stem] \n"
"++++\n"
"\\Huge\n"
"E = \\frac{N (N -1)}{2}\n"
"++++"

#: lecture.adoc:172
msgctxt "lecture.adoc:172"
msgid "== На самом деле, всё ещё хуже! "
msgstr "== In fact, it's even worse! "

#: lecture.adoc:176
msgid ""
"* Uiversal Scalability Law -- полуэмпирическое обобщение закона Амдала\n"
"* &beta; -- параметр, определяющий cohesion (межпоточную координацию)\n"
"* хорошо ложится на эмпирические данные"
msgstr ""
"- Uiversal Scalability Law, a semi-empirical generalization of Amdahl's law\n"
"* &beta; is a parameter that defines cohesion (inter-thread coordination)\n"
"* fits well on empirical data"

#: lecture.adoc:183
msgid ""
"[stem] \n"
"++++\n"
"\\Large\n"
"S = \\frac{N}{1+\\alpha(N-1) + \\beta N (N-1)} = \\frac{N}{1+(\\alpha + "
"\\beta N) (N-1)}\n"
"++++\n"
"== USL: поведение"
msgstr ""
"[stem] \n"
"++++\n"
"\\Large\n"
"S = \\frac{N}{1+\\alpha(N-1) + \\beta N (N-1)} = \\frac{N}{1+(\\alpha + "
"\\beta N) (N-1)}\n"
"++++\n"
"== USL: поведение"

#: lecture.adoc:185
msgid "image::usl.png[{image-70-width}]"
msgstr "image::usl.png[{image-70-width}]"

#: lecture.adoc:187
msgid "== Промежуточный вывод"
msgstr "== Intermediate conclusions"

#: lecture.adoc:192
msgid ""
"* Перед тем, как встать на скользкую тропу многопоточного программирования, "
"подумайте: \n"
"** нужно ли это для решения задачи?\n"
"** насколько многопоточным должно быть решение?\n"
"* Вас предупредили."
msgstr ""
"* Before embarking on the slippery slope of multithreaded programming, "
"consider: \n"
"** Is this necessary to solve the problem?\n"
"** How many threads do you need?\n"
"* You have been warned."

#: lecture.adoc:194
msgid "image::hydra1.jpg[{image-40-width}]"
msgstr "image::hydra1.jpg[{image-40-width}]"

#: lecture.adoc:196
msgid "//https://www.ancient.eu/img/r/p/750x750/3359.jpg?v=1539676109"
msgstr "//https://www.ancient.eu/img/r/p/750x750/3359.jpg?v=1539676109"

#: lecture.adoc:199
msgid "== Часть 1. Зачем нужна и как достигается синхронизация"
msgstr "== Part 1. Why do you need synchronization and how is it achieved"

#: lecture.adoc:201
msgctxt "lecture.adoc:201"
msgid "image::hydra2.jpg[{image-90-width}]"
msgstr "image::hydra2.jpg[{image-90-width}]"

#: lecture.adoc:204
msgid ""
"[[first_example]]\n"
"== Многопоточность в Java (с самой первой версии!)"
msgstr ""
"[[first_example]]\n"
"== Multithreading in Java (from the very first version!)"

#: lecture.adoc:208
msgid ""
"[plantuml, runthr, png]\n"
"----\n"
"@startuml"
msgstr ""
"[plantuml, runthr, png]\n"
"----\n"
"@startuml"

#: lecture.adoc:210
msgid "skinparam dpi 150 "
msgstr "skinparam dpi 150 "

#: lecture.adoc:214
msgid ""
"interface Runnable {\n"
"  void run()\n"
"}"
msgstr ""
"interface Runnable {\n"
"  void run()\n"
"}"

#: lecture.adoc:221
msgid ""
"class Thread {\n"
"  void start()\n"
"  void join([long millis]) throws InterruptedException\n"
"  void interrupt()\n"
"  Thread.state getState()\n"
"}"
msgstr ""
"class Thread {\n"
"  void start()\n"
"  void join([long millis]) throws InterruptedException\n"
"  void interrupt()\n"
"  Thread.state getState()\n"
"}"

#: lecture.adoc:224
msgid "Runnable <|- Thread"
msgstr "Runnable <|- Thread"

#: lecture.adoc:227
msgctxt "lecture.adoc:227"
msgid ""
"@enduml\n"
"----"
msgstr ""
"@enduml\n"
"----"

#: lecture.adoc:243
msgid ""
"[source,java]\n"
"----\n"
"class CalcSquare extends Thread {\n"
"    final int argument;\n"
"    int result;\n"
"    CalcSquare(int argument) {\n"
"        this.argument = argument;\n"
"    }\n"
"    @Override\n"
"    public void run() {\n"
"        //«сложные» вычисления\n"
"        result = argument * argument;\n"
"    }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"class CalcSquare extends Thread {\n"
"    final int argument;\n"
"    int result;\n"
"    CalcSquare(int argument) {\n"
"        this.argument = argument;\n"
"    }\n"
"    @Override\n"
"    public void run() {\n"
"        //\"complex\" calculations\n"
"        result = argument * argument;\n"
"    }\n"
"}\n"
"----"

#: lecture.adoc:245
msgid "== Запуск параллельных вычислений через Thread API"
msgstr "== Run parallel computing via Thread API"

#: lecture.adoc:247
msgid "* NB: в современной реальности вы не будете пользоваться Thread API"
msgstr "* NB: in real world you will not use the Thread API"

#: lecture.adoc:259
msgid ""
"[source,java]\n"
"----\n"
"CalcSquare t1 = new CalcSquare(2);\n"
"CalcSquare t2 = new CalcSquare(3);\n"
"t1.start();\n"
"t2.start();\n"
"t1.join();\n"
"t2.join();\n"
"System.out.printf(\"%d, %d%n\", t1.result, t2.result);\n"
"//otput: 4, 9\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"CalcSquare t1 = new CalcSquare(2);\n"
"CalcSquare t2 = new CalcSquare(3);\n"
"t1.start();\n"
"t2.start();\n"
"t1.join();\n"
"t2.join();\n"
"System.out.printf(\"%d, %d%n\", t1.result, t2.result);\n"
"//otput: 4, 9\n"
"----"

#: lecture.adoc:262
msgid "== Проблемы с shared state"
msgstr "== Problems with shared state"

#: lecture.adoc:271
msgid ""
"[cols=\"50a,.^50a\"]\n"
"|===\n"
"|image::hydraheads.jpg[]\n"
"|\n"
"* Race condition\n"
"* Stale values\n"
"* Reordering\n"
"|==="
msgstr ""
"[cols=\"50a,.^50a\"]\n"
"|===\n"
"|image::hydraheads.jpg[]\n"
"|\n"
"* Race condition\n"
"* Stale values\n"
"* Reordering\n"
"|==="

#: lecture.adoc:273
msgid "== Race condition"
msgstr "== Race condition"

#: lecture.adoc:282
msgid ""
"[source,java]\n"
"----\n"
"class DumbCounter {\n"
"  int count;\n"
"  void increment(){\n"
"    count++;\n"
"  }\n"
"}"
msgstr ""
"[source,java]\n"
"----\n"
"class DumbCounter {\n"
"  int count;\n"
"  void increment(){\n"
"    count++;\n"
"  }\n"
"}"

#: lecture.adoc:285
msgid ""
"DumbCounter c1 = new DumbCounter();\n"
"IntStream.range(0, 1000000).forEach(i->c1.increment());"
msgstr ""
"DumbCounter c1 = new DumbCounter();\n"
"IntStream.range(0, 1000000).forEach(i->c1.increment());"

#: lecture.adoc:288
msgid ""
"DumbCounter c2 = new DumbCounter();\n"
"IntStream.range(0, 1000000).parallel().forEach(i->c2.increment());"
msgstr ""
"DumbCounter c2 = new DumbCounter();\n"
"IntStream.range(0, 1000000).parallel().forEach(i->c2.increment());"

#: lecture.adoc:290
msgid "System.out.printf(\"%d, %d%n\", c1.count, c2.count);"
msgstr "System.out.printf(\"%d, %d%n\", c1.count, c2.count);"

#: lecture.adoc:293
msgid ""
"//1000000,??????\n"
"----"
msgstr ""
"//1000000,??????\n"
"----"

#: lecture.adoc:296
msgid "== Stale values"
msgstr "== Stale values"

#: lecture.adoc:301
msgid ""
"[source,java]\n"
"----\n"
"class DumbWayToFallAsleep implements Runnable {\n"
"  private boolean asleep;"
msgstr ""
"[source,java]\n"
"----\n"
"class DumbWayToFallAsleep implements Runnable {\n"
"  private boolean asleep;"

#: lecture.adoc:305
msgctxt "lecture.adoc:305"
msgid ""
"  public void setAsleep(boolean asleep){\n"
"    this.asleep = asleep;\n"
"  }"
msgstr ""
"  public void setAsleep(boolean asleep){\n"
"    this.asleep = asleep;\n"
"  }"

#: lecture.adoc:315
msgid ""
"  @Override\n"
"  public void run() {\n"
"    while (!asleep){\n"
"      //countSomeSheep\n"
"      //УСНЁМ ЛИ МЫ?\n"
"    }\n"
"  }\n"
"}\n"
"----"
msgstr ""
"  @Override\n"
"  public void run() {\n"
"    while (!asleep){\n"
"      //countSomeSheep\n"
"      //УСНЁМ ЛИ МЫ?\n"
"    }\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:318
msgid "== Reordering"
msgstr "== Reordering"

#: lecture.adoc:339
msgid ""
"[source,java]\n"
"----\n"
"class PossibleReordering {\n"
"  static int x = 0, y = 0, a = 0, b = 0;\n"
"  public static void main(String... args) \n"
"                throws InterruptedException {\n"
"    //другой способ запуска треда (тоже не будете пользоваться)\n"
"    Thread one = new Thread(() -> {\n"
"        a = 1; x = b;\n"
"    });\n"
"    Thread two = new Thread(() -> {\n"
"        b = 1; y = a;\n"
"    });\n"
"    one.start(); two.start();\n"
"    one.join();  two.join();\n"
"    System.out.printf(\"%d,%d\", x, y);\n"
"    //??,??\n"
"  }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"class PossibleReordering {\n"
"  static int x = 0, y = 0, a = 0, b = 0;\n"
"  public static void main(String... args) \n"
"                throws InterruptedException {\n"
"    //another method of starting a thread (you won't use it as well)\n"
"    Thread one = new Thread(() -> {\n"
"        a = 1; x = b;\n"
"    });\n"
"    Thread two = new Thread(() -> {\n"
"        b = 1; y = a;\n"
"    });\n"
"    one.start(); two.start();\n"
"    one.join();  two.join();\n"
"    System.out.printf(\"%d,%d\", x, y);\n"
"    //??,??\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:342
msgid "== Промежуточные выводы"
msgstr "== Intermediate conclusions"

#: lecture.adoc:344
msgid ""
"* Из-за reordering и других низкоуровневых особенностей _нельзя_ рассуждать "
"о результате работы одного треда с точки зрения другого треда как о "
"промежуточном результате выполнения исходного кода. "
msgstr ""
"* Due to reordering and other low-level features, it is _impossible_ to "
"reason about the result of one thread from the point of view of another "
"thread as an intermediate result of the execution of the source code. "

#: lecture.adoc:346
msgid "* Все проблемы с параллельными вычислениями связаны с shared state."
msgstr "* All problems with parallel computing are related to shared state."

#: lecture.adoc:348
msgid "* Показанные здесь проблемы проявляются недетерминированно."
msgstr "* The problems shown here are nondeterministic."

#: lecture.adoc:350
msgid ""
"* Любая программа с доступом к shared state без должной синхронизации -- "
"_сломана_, даже если «вчера это работало на моей машине»."
msgstr ""
"* Any program with shared state access without proper synchronization is "
"_broken_, even if \"yesterday it worked on my machine\"."

#: lecture.adoc:352
msgid "== Модель памяти"
msgstr "== Memory model"

#: lecture.adoc:357
msgid ""
"[source,java]\n"
"----\n"
"int aVariable = 42; \n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"int aVariable = 42; \n"
"----"

#: lecture.adoc:359
msgid ""
"* Модель памяти (Java Memory Model, JMM) -- спецификация языка и виртуальной "
"машины, отвечающая на вопрос: «при каких условиях поток, читающий переменную "
"`aVariable`, увидит значение 42?»"
msgstr ""
"* Java Memory Model (JMM) -- A language and virtual machine specification "
"that answers the question, \"Under what conditions will a thread reading the "
"'aVariable' see a value of 42?\""

#: lecture.adoc:361
msgid "== Happens-before"
msgstr "== Happens-before"

#: lecture.adoc:363
msgid ""
"* JMM определяет частичный порядок на всех действиях в Java-программе, "
"называемый _happens-before_."
msgstr ""
"* JMM defines a partial order on all actions in a Java program, called "
"_happens before_."

#: lecture.adoc:365
msgid ""
"* Отношение _happens-before_ транзитивно: stem:[A \\prec B \\wedge B \\prec "
"C \\Rightarrow A \\prec C]"
msgstr ""
"* The _happens-before_ relation is transitive: stem:[A \\prec B \\wedge B "
"\\prec C \\Rightarrow A \\prec C]"

#: lecture.adoc:367
msgid ""
"* Чтобы действие B гарантированно видело результат работы действия A, "
"достаточно, чтобы stem:[A \\prec B]."
msgstr ""
"* For action B to be guaranteed to see the result of action A, it is "
"sufficient that stem:[A \\prec B]."

#: lecture.adoc:369
msgid "== Program order rule"
msgstr "== Program order rule"

#: lecture.adoc:371
msgid ""
"* В рамках одного треда все действия _happens-before_ в порядке их "
"определения в исходном коде программы. "
msgstr ""
"* Within one thread, all actions _happens before_ in the order of their "
"definition in the source code of the program. "

#: lecture.adoc:373
msgid "* Иными словами, однопоточные программы выполняются без сюрпризов."
msgstr ""
"* In other words, single-threaded programs are executed without surprises."

#: lecture.adoc:375
msgid "== Thread start & thread termination rule"
msgstr "== Thread start & thread termination rule"

#: lecture.adoc:379
msgid ""
"* Вызов `threadA.start()` _happens-before_ всех операций в потоке "
"`threadA`.\n"
"* Любая операция в потоке `threadA` _happens-before_ обнаружения другим "
"потоком завершения `threadA`, либо путём выхода из `threadA.join()`, либо "
"путём проверки `threadA.isAlive() == false`.\n"
"* Благодаря этому правилу, <<first_example,наш самый первый пример>> на "
"параллелизацию работает корректно."
msgstr ""
"* Calling 'threadA.start()' _happens-before_ all operations on the 'threadA' "
"thread.\n"
"* Any operation on the 'threadA' _happens-before_ the detection of the "
"completion of 'threadA' by another thread, either by exiting 'threadA."
"join()' or by checking 'threadA.isAlive() == false'.\n"
"* Due to this rule, <<first_example, our very first example>> works "
"correctly."

#: lecture.adoc:382
msgid "== Ключевое слово volatile"
msgstr "== `volatile` keyword"

#: lecture.adoc:384
msgid ""
"* Переменные классов могут быть определены с ключевым словом `volatile`."
msgstr "* Class variables can be defined with the `volatile` keyword."

#: lecture.adoc:386
msgid ""
"* *Запись в `volatile`-переменную _happens-before_ чтения из этой переменной "
"в другом потоке.*"
msgstr ""
"* *Writing to a `volatile` variable _happens-before_ reading from this "
"variable on another thread.*"

#: lecture.adoc:388
msgid ""
"* Это автоматом делает видимыми изменения в других переменных. Полагаться на "
"это не рекомендуется: это работает, но делает код хрупким. В процессе "
"рефакторинга можно поменять порядок доступа к переменным и тем самым "
"незаметно поломать программу. "
msgstr ""
"* This automatically makes changes in all the other variables visible. "
"Relying on this is not recommended: it works, but it makes the code fragile. "
"In the process of refactoring, you can change the order of access to "
"variables and thereby accidentally break the program. "

#: lecture.adoc:390
msgid "== Чиним stale value при помощи volatile"
msgstr "== Fix stale value using volatile"

#: lecture.adoc:395
msgid ""
"[source,java]\n"
"----\n"
"class NotSoDumbWayToFallAsleep implements Runnable {\n"
"  private volatile boolean asleep;"
msgstr ""
"[source,java]\n"
"----\n"
"class NotSoDumbWayToFallAsleep implements Runnable {\n"
"  private volatile boolean asleep;"

#: lecture.adoc:399
msgctxt "lecture.adoc:399"
msgid ""
"  public void setAsleep(boolean asleep){\n"
"    this.asleep = asleep;\n"
"  }"
msgstr ""
"  public void setAsleep(boolean asleep){\n"
"    this.asleep = asleep;\n"
"  }"

#: lecture.adoc:409
msgid ""
"  @Override\n"
"  public void run() {\n"
"    while (!asleep){\n"
"      //countSomeSheep\n"
"      //...\n"
"    }\n"
"  }\n"
"}\n"
"----"
msgstr ""
"  @Override\n"
"  public void run() {\n"
"    while (!asleep){\n"
"      //countSomeSheep\n"
"      //...\n"
"    }\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:411
msgid "== final-поля"
msgstr "== `final` fields"

#: lecture.adoc:413
msgid ""
"* Если объект правильно опубликован, т. е.  _ссылка на него не утекает во "
"время выполнения конструктора_ --  `final`-поля объекта доступны всем тредам "
"без синхронизации."
msgstr ""
"* If the object is correctly published, i.e. if _reference to `this` does "
"not leak from constructor_ -- `final` fields of the object are available to "
"all the threads without synchronization."

#: lecture.adoc:415
msgid ""
"* Лучший способ борьбы с проблемами mutable state -- использовать immutable "
"state где только возможно."
msgstr ""
"* The best way to deal with mutable state problems is to use immutable state "
"wherever possible."

#: lecture.adoc:417
msgid "== Неатомарные операции: final не годится, volatile не спасёт"
msgstr "== Non-atomic operations: final is not good, volatile will not save us"

#: lecture.adoc:431
msgid ""
"[cols=\"50a,50a\"]\n"
"|===\n"
"|\n"
"[source,java]\n"
"----\n"
"class DumbCounter {\n"
"  int count;\n"
"  void increment(){\n"
"    count++;\n"
"  }\n"
"}\n"
"----\n"
"(Мы можем объявить `count` как volatile, но ситуация не улучшится.)"
msgstr ""
"[cols=\"50a,50a\"]\n"
"|===\n"
"|\n"
"[source,java]\n"
"----\n"
"class DumbCounter {\n"
"  int count;\n"
"  void increment(){\n"
"    count++;\n"
"  }\n"
"}\n"
"----\n"
"(We can declare `count` as `volatile`, but this won't help.)"

#: lecture.adoc:436
msgid ""
"|[source,java]\n"
"----\n"
"void dumbMoneyTransfer(\n"
"  int from, int to, int amount){"
msgstr ""
"|[source,java]\n"
"----\n"
"void dumbMoneyTransfer(\n"
"  int from, int to, int amount){"

#: lecture.adoc:441
msgid ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;\n"
"}\n"
"----"
msgstr ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;\n"
"}\n"
"----"

#: lecture.adoc:444
msgid ""
"(Кстати, `volatile array` -- не массив `volatile`-элементов. И вообще в Java "
"просто так массив `volatile`-элементов не создать.)\n"
"|==="
msgstr ""
"(By the way, a `volatile` array is not an array of `volatile` elements, and "
"in Java you can't just create an array of `volatile` elements that easy.)\n"
"|==="

#: lecture.adoc:454
msgid ""
"== Несинхронизированное выполнение\n"
"[plantuml, nonsync, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"participant Client1\n"
"participant Client2\n"
"participant Bank"
msgstr ""
"== Unsynchronized execution\n"
"[plantuml, nonsync, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"participant Client1\n"
"participant Client2\n"
"participant Bank"

#: lecture.adoc:457
msgctxt "lecture.adoc:457"
msgid ""
"Client1 -> Bank: transfer\n"
"activate Bank"
msgstr ""
"Client1 -> Bank: transfer\n"
"activate Bank"

#: lecture.adoc:460
msgid ""
"Client2 -> Bank: transfer\n"
"Bank --> Client1 "
msgstr ""
"Client2 -> Bank: transfer\n"
"Bank --> Client1 "

#: lecture.adoc:464
msgid ""
"Bank --> Client2\n"
"deactivate Bank"
msgstr ""
"Bank --> Client2\n"
"deactivate Bank"

#: lecture.adoc:467
msgctxt "lecture.adoc:467"
msgid ""
"@enduml\n"
"----"
msgstr ""
"@enduml\n"
"----"

#: lecture.adoc:477
msgid ""
"== Синхронизированное выполнение\n"
"[plantuml, sync, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"participant Client1\n"
"participant Client2\n"
"participant Lock\n"
"participant Bank"
msgstr ""
"== Synchronized execution\n"
"[plantuml, sync, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"participant Client1\n"
"participant Client2\n"
"participant Lock\n"
"participant Bank"

#: lecture.adoc:483
msgid ""
"Client1 -> Lock: lock\n"
"activate Lock\n"
"Lock --> Client1\n"
"deactivate Lock"
msgstr ""
"Client1 -> Lock: lock\n"
"activate Lock\n"
"Lock --> Client1\n"
"deactivate Lock"

#: lecture.adoc:486
msgctxt "lecture.adoc:486"
msgid ""
"Client1 -> Bank: transfer\n"
"activate Bank"
msgstr ""
"Client1 -> Bank: transfer\n"
"activate Bank"

#: lecture.adoc:489
msgid ""
"Client2 -> Lock: lock\n"
"activate Lock"
msgstr ""
"Client2 -> Lock: lock\n"
"activate Lock"

#: lecture.adoc:492
msgid ""
"Bank --> Client1 \n"
"deactivate Bank"
msgstr ""
"Bank --> Client1 \n"
"deactivate Bank"

#: lecture.adoc:497
msgid ""
"Client1 -> Lock: unlock\n"
"Lock --> Client1\n"
"Lock --> Client2\n"
"deactivate Lock"
msgstr ""
"Client1 -> Lock: unlock\n"
"Lock --> Client1\n"
"Lock --> Client2\n"
"deactivate Lock"

#: lecture.adoc:502
msgid ""
"Client2 -> Bank: transfer\n"
"activate Bank\n"
"Bank --> Client2\n"
"deactivate Bank"
msgstr ""
"Client2 -> Bank: transfer\n"
"activate Bank\n"
"Bank --> Client2\n"
"deactivate Bank"

#: lecture.adoc:505
msgctxt "lecture.adoc:505"
msgid ""
"@enduml\n"
"----"
msgstr ""
"@enduml\n"
"----"

#: lecture.adoc:508
msgid "== Блокировки"
msgstr "== Locks"

#: lecture.adoc:514
msgid ""
"[source,java]\n"
"----\n"
"//Reentrant так называется потому,\n"
"//что одному и тому же треду позволено входить повторно\n"
"private ReentrantLock bankLock = new ReentrantLock(); "
msgstr ""
"[source,java]\n"
"----\n"
"//Reentrant is so called because\n"
"//the same thread is allowed to enter again\n"
"private ReentrantLock bankLock = new ReentrantLock(); "

#: lecture.adoc:527
msgid ""
"void moneyTransfer(int from, int to, int amount) {\n"
"  bankLock.lock();\n"
"  try {\n"
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;\n"
"  } finally {\n"
"    bankLock.unlock();\n"
"  }\n"
"}\n"
"----\n"
"[.fragment]\n"
"Если вы задались вопросом: «где гарантии, что после выхода из блокировки "
"тред увидит результат работы предыдущего треда?» -- поздравляю, вы начали "
"что-то понимать."
msgstr ""
"void moneyTransfer(int from, int to, int amount) {\n"
"  bankLock.lock();\n"
"  try {\n"
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;\n"
"  } finally {\n"
"    bankLock.unlock();\n"
"  }\n"
"}\n"
"----\n"
"[.fragment]\n"
"Did you asked yourself: “where is the guarantee that after the exit from "
"blocking, the thread will see the result of the work of the previous "
"thread?” If you did, then you had begun to understand something."

#: lecture.adoc:529
msgid "== JMM Monitor Lock Rule"
msgstr "== JMM Monitor Lock Rule"

#: lecture.adoc:532
msgid ""
"* Разблокировка (unlocking) _happens-before_ другой блокировки (locking) "
"того же самого «замка» (lock).\n"
"* Поэтому защищённые блокировкой переменные объявлять как `volatile` уже не "
"нужно."
msgstr ""
"* Unlocking _happens before_ another locking of the same lock.\n"
"* Therefore, lock-protected variables should no longer be declared as "
"`volatile`."

#: lecture.adoc:534
msgid "== В чём проблема здесь?"
msgstr "== What's the problem here?"

#: lecture.adoc:540
msgid ""
"[source,java]\n"
"----\n"
"while (accounts[from] < amount) {\n"
"    //wait ....\n"
"}"
msgstr ""
"[source,java]\n"
"----\n"
"while (accounts[from] < amount) {\n"
"    //wait ....\n"
"}"

#: lecture.adoc:550
msgid ""
"bankLock.lock();\n"
"try {\n"
"  //transfer funds ...\n"
"} finally {\n"
"  bankLock.unlock();\n"
"}\n"
"----\n"
"[.fragment]\n"
"Доступ к `accounts[from]` не синхронизирован, но даже если бы он был "
"синхронизирован, кто-то смог бы уменьшить количество денег до вхождения в "
"блок transfer funds."
msgstr ""
"bankLock.lock();\n"
"try {\n"
"  transfer funds ...\n"
"} finally {\n"
"  bankLock.unlock();\n"
"}\n"
"----\n"
"[.fragment]\n"
"Access to `accounts[from]` is not synchronized, but even if it were "
"synchronized, someone would be able to reduce the amount of money before "
"entering the transfer funds block."

#: lecture.adoc:552
msgid "== В чём пробема здесь?"
msgstr "== What's the problem here?"

#: lecture.adoc:567
msgid ""
"[source,java]\n"
"----\n"
"bankLock.lock();\n"
"try {\n"
"  while (accounts[from] < amount) {\n"
"    //wait ....\n"
"  }\n"
"  //transfer funds ...\n"
"} finally {\n"
"  bankLock.unlock();\n"
"}\n"
"----\n"
"[.fragment]\n"
"Мы заблокировали `bankLock` и ждём, пока кто-то закинет денег. Но никто "
"никогда не сможет это сделать, т. к. `bankLock` занят нами."
msgstr ""
"[source,java]\n"
"----\n"
"bankLock.lock();\n"
"try {\n"
"  while (accounts[from] < amount) {\n"
"    wait ....\n"
"  }\n"
"  transfer funds ...\n"
"} finally {\n"
"  bankLock.unlock();\n"
"}\n"
"----\n"
"[.fragment]\n"
"We have acquired `bankLock` and are waiting for someone to top up the "
"account. But no one will ever be able to do it, because `bankLock` is locked "
"by us."

#: lecture.adoc:569
msgid "== Condition Objects"
msgstr "== Condition Objects"

#: lecture.adoc:574
msgid ""
"[source,java]\n"
"----\n"
"private ReentrantLock bankLock = new ReentrantLock(); \n"
"private Condition sufficientFunds = bankLock.newCondition();"
msgstr ""
"[source,java]\n"
"----\n"
"private ReentrantLock bankLock = new ReentrantLock(); \n"
"private Condition sufficientFunds = bankLock.newCondition();"

#: lecture.adoc:580
msgid ""
"void moneyTransfer(int from, int to, int amount) {\n"
"  bankLock.lock();\n"
"  try {\n"
"    while (accounts[from] < amount)\n"
"      sufficientFunds.await();"
msgstr ""
"void moneyTransfer(int from, int to, int amount) {\n"
"  bankLock.lock();\n"
"  try {\n"
"    while (accounts[from] < amount)\n"
"      sufficientFunds.await();"

#: lecture.adoc:583
msgctxt "lecture.adoc:583"
msgid ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"
msgstr ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"

#: lecture.adoc:591
msgid ""
"    sufficientFunds.signalAll();\n"
"  } finally {\n"
"    bankLock.unlock();\n"
"  }\n"
"}\n"
"----\n"
"== Condition Objects: что происходит?"
msgstr ""
"    sufficientFunds.signalAll();\n"
"  } finally {\n"
"    bankLock.unlock();\n"
"  }\n"
"}\n"
"----\n"
"== Condition Objects: What happens?"

#: lecture.adoc:598
msgid ""
"* `await()` отпускает блокировку и переводит тред в ждущее состояние,\n"
"* `signalAll()` сигнализирует всем ждущим тредам, что что-то поменялось,\n"
"* выход из `await()` _снова захватывает блокировку_.\n"
"* При выходе из `await()` мы вновь проверяем условие, потому что:\n"
"** сигнал мог быть по другому поводу,\n"
"** возможны «спонтанные пробуждения»."
msgstr ""
"* 'await()' releases the lock and puts the thread into a waiting state,\n"
"* 'signalAll()' signals to all waiting threads that something has changed,\n"
"* exiting 'await()' _again acquires the lock_.\n"
"* When exiting 'await()' we check the condition again because:\n"
"** the signal could be sent for another reason,\n"
"** \"spurious wakeups\" are possible."

#: lecture.adoc:600
msgid "== Контрольный вопрос"
msgstr "== Question"

#: lecture.adoc:602
msgid ""
"* Чем гарантировано, что при выходе из `await()` мы увидим изменения, "
"сделанные другим тредом?"
msgstr ""
"* How is it guaranteed that when we leave `await()` we will see changes made "
"by another thread?"

#: lecture.adoc:605
msgid ""
"[.fragment]\n"
"* При выходе из `await()` мы снова захватываем блокировку, работает JMM "
"Monitor Lock Rule."
msgstr ""
"[.fragment]\n"
"* When exiting `await()` we capture the lock again, the JMM Monitor Lock "
"Rule is working."

#: lecture.adoc:613
msgid ""
"== Правильный паттерн ожидания condition\n"
"[source,java]\n"
"----\n"
"while (!okToProceed())\n"
"  condition.await();\n"
"----\n"
"== Intrinsic lock"
msgstr ""
"== Correct condition waiting pattern\n"
"[source,java]\n"
"----\n"
"while (!okToProceed())\n"
"  condition.await();\n"
"----\n"
"== Intrinsic lock"

#: lecture.adoc:616
msgid ""
"* Начиная с Java 1.0, каждый объект имеет встроенный (intrinsic) lock.\n"
"* У каждого intrinsic lock есть один condition."
msgstr ""
"* Starting with Java 1.0, every object has an intrinsic lock.\n"
"* Each intrinsic lock has one condition."

#: lecture.adoc:624
msgid ""
"== То же самое, с помощью intrinsic lock\n"
"[source,java]\n"
"----\n"
"//enter intrinsic lock on *this*\n"
"synchronized void moneyTransfer(int from, int to, int amount) {\n"
"    while (accounts[from] < amount)\n"
"      wait(); //wait on intrinsic object's lock condition"
msgstr ""
"== Same with intrinsic lock\n"
"[source,java]\n"
"----\n"
"//enter intrinsic lock on *this*\n"
"synchronized void moneyTransfer(int from, int to, int amount) {\n"
"    while (accounts[from] < amount)\n"
"      wait(); //wait on intrinsic object's lock condition"

#: lecture.adoc:627
msgctxt "lecture.adoc:627"
msgid ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"
msgstr ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"

#: lecture.adoc:631
msgid ""
"    notifyAll(); //notify all threads waiting on the condition\n"
"}\n"
"----"
msgstr ""
"    notifyAll(); //notify all threads waiting on the condition\n"
"}\n"
"----"

#: lecture.adoc:633
msgid "== Synchronized-блок"
msgstr "== `synchronized` block"

#: lecture.adoc:635
msgid "Другая форма использования intrinsic locks:"
msgstr "Another form of using intrinsic locks:"

#: lecture.adoc:643
msgid ""
"[source,java]\n"
"----\n"
"private Object lock = new Object();\n"
"void moneyTransfer(int from, int to, int amount) {\n"
"  synchronized (lock) {\n"
"    while (accounts[from] < amount)\n"
"      lock.wait();"
msgstr ""
"[source,java]\n"
"----\n"
"private Object lock = new Object();\n"
"void moneyTransfer(int from, int to, int amount) {\n"
"  synchronized (lock) {\n"
"    while (accounts[from] < amount)\n"
"      lock.wait();"

#: lecture.adoc:646
msgctxt "lecture.adoc:646"
msgid ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"
msgstr ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"

#: lecture.adoc:651
msgid ""
"    lock.notifyAll();\n"
"  }\n"
"}\n"
"----"
msgstr ""
"    lock.notifyAll();\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:662
msgid ""
"== Промежуточный итог по intrinsic conditions\n"
"* Нужно работать по строгому паттерну: \n"
"** синхронизация,\n"
"** while-loop wait,\n"
"** нотификация.\n"
"* Нужно держать в уме:\n"
"** по intrinsic lock какого объекта синхронизируемся,\n"
"** по condition какого объекта ждём,\n"
"** треды, ждущие на condition какого объекта нотифицируем (это всё должен "
"быть один объект).\n"
"* В общем, это низкоуровневый и сложный механизм. Его понимание пригодится "
"на собеседованиях, но скорее всего, вам не надо будет им пользоваться."
msgstr ""
"== Intermediate conclusions for intrinsic conditions\n"
"* It is necessary to follow the strict pattern: \n"
"** synchronization,\n"
"** while-loop wait,\n"
"** notification.\n"
"* You need to keep in mind:\n"
"** the object whose intrinsic lock we are capturing,\n"
"** the object whose condition we use for waiting,\n"
"** threads waiting on which condition we notify (it all should relate to the "
"same object).\n"
"* In general, this is a low-level and complex mechanism. Its understanding "
"will be useful during job interviews, but most likely, you will not need to "
"use it."

#: lecture.adoc:671
msgid ""
"== Теперь нам понятен смысл всех возможных состояний треда\n"
"[graphviz,\"threadstates.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"rankdir=\"LR\"\n"
"new -> runnable[label=\"start\"]\n"
"runnable -> terminated[xlabel=\"run\\nmethod exit\"]"
msgstr ""
"== Now we understand the meaning of all the possible thread states\n"
"[graphviz,\"threadstates.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"rankdir=\"LR\"\n"
"new -> runnable[label=\"start\"]\n"
"runnable -> terminated[xlabel=\"run\\nmethod exit\"]"

#: lecture.adoc:674
msgid ""
"runnable -> blocked [label=\"aquiring a lock\"]\n"
"blocked -> runnable [label=\"lock aquired\"]"
msgstr ""
"runnable -> blocked [label=\"aquiring a lock\"]\n"
"blocked -> runnable [label=\"lock aquired\"]"

#: lecture.adoc:677
msgid ""
"runnable -> waiting [label=\"waiting for notification\"]\n"
"waiting -> runnable [label=\"notification occured\"]"
msgstr ""
"runnable -> waiting [label=\"waiting for notification\"]\n"
"waiting -> runnable [label=\"notification occured\"]"

#: lecture.adoc:680
msgid ""
"runnable -> TW  [label=\"waiting for timeout or notification\"]\n"
"TW -> runnable [xlabel=\"timeout or notification occured\"]"
msgstr ""
"runnable -> TW  [label=\"waiting for timeout or notification\"]\n"
"TW -> runnable [xlabel=\"timeout or notification occured\"]"

#: lecture.adoc:682
msgid "TW[label=\"timed\\nwaiting\"]"
msgstr "TW[label=\"timed\\nwaiting\"]"

#: lecture.adoc:685
msgid ""
"{rank=same;new;terminated}\n"
"}"
msgstr ""
"{rank=same;new;terminated}\n"
"}"

#: lecture.adoc:687
msgid "----"
msgstr "----"

#: lecture.adoc:689
msgid "== Промежуточный итог по всему вышесказанному"
msgstr "== Intermediate conclusions for all of the above"

#: lecture.adoc:696
msgid ""
"* Где возможно, используйте immutable state: он автоматически "
"потокобезопасен.\n"
"* Используйте volatile переменные или синхронизацию для доступа к mutable "
"state.\n"
"* Удерживайте блокировку во время выполнения операций, которые должны быть "
"атомарными.\n"
"* Повторим ещё раз: *программа с shared mutable state без должной "
"синхронизации -- сломанная программа*.\n"
"* Думайте о потокобезопасности всё время.\n"
"* Понимание JMM помогает"
msgstr ""
"* Where possible, use immutable state: it is automatically thread-safe.\n"
"* Use volatile variables or synchronization to access mutable state.\n"
"* Hold the lock while performing operations that should be atomic.\n"
"* To reiterate: *a program with a shared mutable state without proper "
"synchronization is a broken program*.\n"
"* Think about thread safety all the time.\n"
"* JMM understanding helps"

#: lecture.adoc:699
msgid "== Часть 2. Deadlocks"
msgstr "== Part 2. Deadlocks"

#: lecture.adoc:701
msgctxt "lecture.adoc:701"
msgid "image::hydra2.jpg[{image-90-width}]"
msgstr "image::hydra2.jpg[{image-90-width}]"

#: lecture.adoc:703
msgid "== Deadlock: простой пример"
msgstr "== Deadlock: A Simple Example"

#: lecture.adoc:709
msgid ""
"[plantuml, deadlock, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"hide footbox"
msgstr ""
"[plantuml, deadlock, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"hide footbox"

#: lecture.adoc:714
msgid ""
"participant X\n"
"participant Y\n"
"participant LockA\n"
"participant LockB"
msgstr ""
"participant X\n"
"participant Y\n"
"participant LockA\n"
"participant LockB"

#: lecture.adoc:718
msgid ""
"X -> LockA: lock()\n"
"activate LockA\n"
"LockA --> X: "
msgstr ""
"X -> LockA: lock()\n"
"activate LockA\n"
"LockA --> X: "

#: lecture.adoc:722
msgid ""
"Y -> LockB: lock()\n"
"activate LockB\n"
"LockB --> Y"
msgstr ""
"Y -> LockB: lock()\n"
"activate LockB\n"
"LockB --> Y"

#: lecture.adoc:728
msgid ""
"X -> LockB: lock()\n"
"note right\n"
"  будем ждать\n"
"  вечно\n"
"end note"
msgstr ""
"X -> LockB: lock()\n"
"note right\n"
"  we will wait\n"
"  forever\n"
"end note"

#: lecture.adoc:730
msgid "Y -> LockA: lock()"
msgstr "Y -> LockA: lock()"

#: lecture.adoc:733
msgctxt "lecture.adoc:733"
msgid ""
"@enduml\n"
"----"
msgstr ""
"@enduml\n"
"----"

#: lecture.adoc:735
msgid "== Перепутанный порядок блокировки"
msgstr "== Wrong order of blocking"

#: lecture.adoc:757
msgid ""
"[source,java]\n"
"----\n"
"class LeftRightDeadlock {\n"
"  private final Object left = new Object();\n"
"  private final Object right = new Object();\n"
"  void leftRight() {\n"
"    synchronized (left) {\n"
"      synchronized (right) {\n"
"        doSomething();\n"
"      }\n"
"    }\n"
"  }\n"
"  void rightLeft() {\n"
"    synchronized (right) {\n"
"      synchronized (left) {\n"
"        doSomethingElse();\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"class LeftRightDeadlock {\n"
"  private final Object left = new Object();\n"
"  private final Object right = new Object();\n"
"  void leftRight() {\n"
"    synchronized (left) {\n"
"      synchronized (right) {\n"
"        doSomething();\n"
"      }\n"
"    }\n"
"  }\n"
"  void rightLeft() {\n"
"    synchronized (right) {\n"
"      synchronized (left) {\n"
"        doSomethingElse();\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:759
msgid "== Перепутанный (иногда!) порядок блокировки"
msgstr "== (Sometimes?) wrong order of blocking"

#: lecture.adoc:776
msgid ""
"[source,java]\n"
"----\n"
"void transferMoney(Account fromAccount, Account toAccount, \n"
"                     int amount) throws InsufficientFundsException {\n"
"  synchronized (fromAccount) {\n"
"    synchronized (toAccount) {\n"
"      if (fromAccount.getBalance() < amount)\n"
"        throw new InsufficientFundsException();\n"
"      else {\n"
"        fromAccount.debit(amount);\n"
"        toAccount.credit(amount);\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"void transferMoney(Account fromAccount, Account toAccount, \n"
"                     int amount) throws InsufficientFundsException {\n"
"  synchronized (fromAccount) {\n"
"    synchronized (toAccount) {\n"
"      if (fromAccount.getBalance() < amount)\n"
"        throw new InsufficientFundsException();\n"
"      else {\n"
"        fromAccount.debit(amount);\n"
"        toAccount.credit(amount);\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"----"

#: lecture.adoc:778
msgid "== Выводы"
msgstr "== Conclusions"

#: lecture.adoc:782
msgid ""
"* Если процедура захватывает несколько блокировок, возможен deadlock.\n"
"* Во избежание deadlocks нужно следить за тем, чтобы блокировки всегда "
"захватывались в одном и том же порядке. Иногда неочевидно, как это сделать.\n"
"* Если вы захватили блокировку -- закончите с ней как можно быстрее, не "
"вызывайте внешних методов."
msgstr ""
"* If function captures more than one lock, deadlock is possible.\n"
"* To avoid deadlocks, you need to make sure that the locks are always "
"captured in the same order. Sometimes it's not obvious how to do it.\n"
"* If you have captured a lock -- finish with it as quickly as possible, do "
"not call external methods."

#: lecture.adoc:784
msgid "== Часть 3. Потокобезопасные структуры данных"
msgstr "== Part 3. Thread-safe data structures"

#: lecture.adoc:786
msgctxt "lecture.adoc:786"
msgid "image::hydra2.jpg[{image-90-width}]"
msgstr "image::hydra2.jpg[{image-90-width}]"

#: lecture.adoc:788
msgid "== Неблокирующие алгоритмы"
msgstr "== Non-blocking algorithms"

#: lecture.adoc:793
msgid ""
"* Блокировка (через `synchronized` или `ReentrantLock`) решает вопрос "
"координации действий разных тредов с переменной.\n"
"* Но если много тредов конкурируют за блокировку (high lock contention), "
"затраты ресурсов на координацию тредов становятся значительными.\n"
"* Альтернативой являются _неблокирующие алгоритмы_, использующие поддержку "
"специальных атомарных машинных инструкций (compare-and-swap).\n"
"* В Java-библиотеке доступны _классы атомарных переменных_ и "
"_потокобезопасные коллекции_, реализованные в том числе на неблокирующих "
"алгоритмах."
msgstr ""
"* Locking (via `synchronized` or `ReentrantLock`) solves the issue of "
"coordinating the actions of different threads with a variable.\n"
"* But if many threads compete for the lock (high lock contention), the cost "
"of coordinating the threads becomes significant.\n"
"* The alternative is _non-blocking algorithms_ that use special atomic "
"machine instructions (compare-and-swap).\n"
"* In the Java library, _classes of atomic variables_ and _thread-safe "
"collections_ are available, including those implementing non-blocking "
"algorithms."

#: lecture.adoc:795
msgid "== Atomics "
msgstr "== Atomics "

#: lecture.adoc:802
msgid ""
"* `package java.util.concurrent.atomic`\n"
"** `AtomicBoolean`, `AtomicInteger`, `AtomicLong`, `AtomicReference`.\n"
"** `AtomicIntegerArray`, `AtomicLongArray`, `AtomicReferenceArray`.\n"
"* Могут быть использованы как «улучшенные volatile-переменные», т. к. "
"результат вызова `set(...)` виден другим тредам при вызове `get(...)`\n"
"* Поддерживают атомарные операции."
msgstr ""
"* `package java.util.concurrent.atomic`\n"
"** `AtomicBoolean`, `AtomicInteger`, `AtomicLong`, `AtomicReference`.\n"
"** `AtomicIntegerArray`, `AtomicLongArray`, `AtomicReferenceArray`.\n"
"* Can be used as \"enhanced volatiles\", as the result of calling `set(...)` "
"is visible to other threads via `get(...)`\n"
"* Support atomic operations."

#: lecture.adoc:804
msgid "== Aтомарные операции в классах атомарных переменных"
msgstr "== Atomic operations in atomic variable classes"

#: lecture.adoc:807
msgid ""
"----\n"
"getAndSet(newValue)    compareAndSet(expect, update) "
msgstr ""
"----\n"
"getAndSet(newValue)    compareAndSet(expect, update) "

#: lecture.adoc:809
msgid "incrementAndGet()      decrementAndGet()"
msgstr "incrementAndGet()      decrementAndGet()"

#: lecture.adoc:811
msgid "getAndIncrement()      getAndDecrement()"
msgstr "getAndIncrement()      getAndDecrement()"

#: lecture.adoc:813
msgid "getAndAdd(delta)       addAndGet(delta)"
msgstr "getAndAdd(delta)       addAndGet(delta)"

#: lecture.adoc:816
msgid ""
"getAndUpdate(updateFunction)\n"
"updateAndGet(updateFunction)"
msgstr ""
"getAndUpdate(updateFunction)\n"
"updateAndGet(updateFunction)"

#: lecture.adoc:820
msgid ""
"getAndAccumulate(x, accumulatorBiFunction)\n"
"accumulateAndGet(x, accumulatorBiFunction)\n"
"----"
msgstr ""
"getAndAccumulate(x, accumulatorBiFunction)\n"
"accumulateAndGet(x, accumulatorBiFunction)\n"
"----"

#: lecture.adoc:823
msgid "== Потокобезопасные коллекции"
msgstr "== Thread-safe collections"

#: lecture.adoc:827
msgid ""
"* В ранних версиях Java можно было «сделать» коллекцию потокобезопасной, "
"обернув в `Collections.synchronizedXXX(...)`. Это сериализовывало любой "
"доступ к внутреннему состоянию коллекции. Из-за поддержки обратной "
"совместимости сейчас так тоже можно, но не нужно.\n"
"* Цена такого решения -- плохой параллелизм: конкуренция за блокировку (lock "
"contention).\n"
"* С версии 5 появились классы, специально разработанные для "
"потокобезопасности, с меньшим количеством блокировок.\n"
"* Их использование является _предпочтительным_."
msgstr ""
"* In earlier versions of Java, it was possible to \"make\" a collection "
"thread-safe by wrapping it in `Collections.synchronizedXXX(...)`. This "
"serialized any access to the internal state of the collection. Because of "
"backward compatibility support, doing this is still possible, but not "
"recommended.\n"
"* The price of such a solution is high lock contention.\n"
"* Version 5 introduces classes specifically designed for thread safety, with "
"fewer locks.\n"
"* Their use is _preferred_."

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:132"
#~ msgid "^.^|"
#~ msgstr "^.^|"

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:148"
#~ msgid "^.^|"
#~ msgstr "^.^|"

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:172"
#~ msgid "== На самом деле, всё ещё хуже! "
#~ msgstr "== На самом деле, всё ещё хуже! "

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:399"
#~ msgid ""
#~ "  public void setAsleep(boolean asleep){\n"
#~ "    this.asleep = asleep;\n"
#~ "  }"
#~ msgstr ""
#~ "  public void setAsleep(boolean asleep){\n"
#~ "    this.asleep = asleep;\n"
#~ "  }"

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:467"
#~ msgid ""
#~ "@enduml\n"
#~ "----"
#~ msgstr ""
#~ "@enduml\n"
#~ "----"

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:486"
#~ msgid ""
#~ "Client1 -> Bank: transfer\n"
#~ "activate Bank"
#~ msgstr ""
#~ "Client1 -> Bank: transfer\n"
#~ "activate Bank"

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:505"
#~ msgid ""
#~ "@enduml\n"
#~ "----"
#~ msgstr ""
#~ "@enduml\n"
#~ "----"

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:627"
#~ msgid ""
#~ "    accounts[from]-=amount;\n"
#~ "    accounts[to]+=amount;"
#~ msgstr ""
#~ "    accounts[from]-=amount;\n"
#~ "    accounts[to]+=amount;"

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:646"
#~ msgid ""
#~ "    accounts[from]-=amount;\n"
#~ "    accounts[to]+=amount;"
#~ msgstr ""
#~ "    accounts[from]-=amount;\n"
#~ "    accounts[to]+=amount;"

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:701"
#~ msgid "image::hydra2.jpg[{image-90-width}]"
#~ msgstr "image::hydra2.jpg[{image-90-width}]"

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:733"
#~ msgid ""
#~ "@enduml\n"
#~ "----"
#~ msgstr ""
#~ "@enduml\n"
#~ "----"

#~ msgctxt "./slides10/src/main/asciidoc/lecture.adoc:786"
#~ msgid "image::hydra2.jpg[{image-90-width}]"
#~ msgstr "image::hydra2.jpg[{image-90-width}]"
