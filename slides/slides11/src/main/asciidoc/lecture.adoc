= Core Java. Лекция 11: Java Concurrency (окончание). Annotations
Иван Пономарёв, КУРС/МФТИ
:revealjs_theme: black
:revealjs_customtheme: white_course.css
:revealjs_slideNumber:
:revealjs_history:
:revealjs_progress:
:encoding: UTF-8
:lang: ru
include::_doc_general_attributes.adoc[]
:doctype: article
:toclevels: 3
:imagesdir: images
:source-highlighter: highlightjs
:highlightjsdir: highlight
:icons: font
:iconfont-remote!:
:iconfont-name: font-awesome-4.7.0/css/font-awesome
:revealjs_mouseWheel: true
:revealjs_center: false
:revealjs_transition: none
:revealjs_width: 1600
:revealjs_height: 900
:stem: latexmath


:!figure-caption:

ponomarev@corchestra.ru

icon:twitter[size=lg] @inponomarev

== Часть 3. Потокобезопасные структуры данных

image::hydra2.jpg[{image-90-width}]

== Неблокирующие алгоритмы

* Блокировка (через `synchronized` или `ReentrantLock`) решает вопрос координации действий разных тредов с переменной.
* Но если много тредов конкурируют за блокировку (high lock contention), затраты ресурсов на координацию тредов становятся значительными.
* Альтернативой являются _неблокирующие алгоритмы_, использующие поддержку специальных атомарных машинных инструкций (compare-and-swap).
* В Java-библиотеке доступны _классы атомарных переменных_ и _потокобезопасные коллекции_, реализованные в том числе на неблокирующих алгоритмах.

== Atomics 


* `package java.util.concurrent.atomic`
** `AtomicBoolean`, `AtomicInteger`, `AtomicLong`, `AtomicReference`.
** `AtomicIntegerArray`, `AtomicLongArray`, `AtomicReferenceArray`.
* Могут быть использованы как «улучшенные volatile-переменные», т. к. результат вызова `set(...)` виден другим тредам при вызове `get(...)`
* Поддерживают атомарные операции.

== Aтомарные операции в классах атомарных переменных

[source,text]
----
getAndSet(newValue)    compareAndSet(expect, update) 

incrementAndGet()      decrementAndGet()

getAndIncrement()      getAndDecrement()

getAndAdd(delta)       addAndGet(delta)

getAndUpdate(updateFunction)
updateAndGet(updateFunction)

getAndAccumulate(x, accumulatorBiFunction)
accumulateAndGet(x, accumulatorBiFunction)
----


== Потокобезопасные коллекции

* В ранних версиях Java можно было «сделать» коллекцию потокобезопасной, обернув в `Collections.synchronizedXXX(...)`. Это сериализовывало любой доступ к внутреннему состоянию коллекции. Из-за поддержки обратной совместимости сейчас так тоже можно, но не нужно.
* Цена такого решения -- плохой параллелизм: конкуренция за блокировку (lock contention).
* С версии 5 появились классы, специально разработанные для потокобезопасности, с меньшим количеством блокировок.
* Их использование является _предпочтительным_.


== CopyOnWriteArrayList и CopyOnWriteArraySet
[source,java]
----
class CopyOnWriteArrayList<E> implements List<E>
class CopyOnWriteArraySet<E> extends AbstractSet<E>
----

* Структуры данных на основе массива.
* Пересоздают всё заново при каждой модификации.
* Это дорого, зато все читающие итераторы стабильны.
* Хороши, когда на одну операцию записи приходится много операций чтения.

== ConcurrentLinkedQueue/Deque

[source,java]
----
ConcurrentLinkedQueue<E> extends AbstractQueue<E> 
        implements Queue<E>
ConcurrentLinkedDeque<E> extends AbstractCollection<E>
        implements Deque<E>
----

* Основаны на неблокирующем алгоритме (CAS-операции)
* `poll()` вернёт `null`, если очередь пуста
* Под капотом -- связные/двусвязные списки

== ConcurrentLinkedQueue/Deque

[graphviz]
--
digraph Java {
	rankdir="LR";
	node[shape=plaintext];
	graph [ dpi = 180 ];
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>ConcurrentLinkedQueue</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>item: 4</td>
			</tr>
			<tr>
				<td>next: null</td>
			</tr>
		</table>
	>];
	n1 -> n2[label="tail",fontsize=12,constraint="false"];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>item: null</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>item: 1</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>item: 2</td>
			</tr>
		</table>
	>];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>item: 3</td>
			</tr>
		</table>
	>];
	n6 -> n2[label="next",fontsize=12];
	n5 -> n6[label="next",fontsize=12];
	n4 -> n5[label="next",fontsize=12];
	n3 -> n4[label="next",fontsize=12];
	n1 -> n3[label="head",fontsize=12];
}

--

[graphviz]
--
digraph Java {
	rankdir="LR";
	node[shape=plaintext];
	graph [ dpi = 180 ];
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>ConcurrentLinkedDeque</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>item: 4</td>
			</tr>
			<tr>
				<td>next: null</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>item: 3</td>
			</tr>
		</table>
	>];
	n3 -> n2[label="next",fontsize=12];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>item: 2</td>
			</tr>
		</table>
	>];
	n4 -> n3[label="next",fontsize=12];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>item: 1</td>
			</tr>
		</table>
	>];
	n5 -> n4[label="next",fontsize=12];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>item: null</td>
			</tr>
			<tr>
				<td>prev: null</td>
			</tr>
		</table>
	>];
	n6 -> n5[label="next",fontsize=12];
	n5 -> n6[label="prev",fontsize=12,constraint=false];
	n4 -> n5[label="prev",fontsize=12,constraint=false];
	n3 -> n4[label="prev",fontsize=12,constraint=false];
	n2 -> n3[label="prev",fontsize=12,constraint=false];
	n1 -> n2[label="tail",fontsize=12,constraint=false];
	n1 -> n6[label="head",fontsize=12];
}

--


== Блокирующие очереди: средство реализации producer-consumer pattern

[plantuml, blockingqueue, png]
----
@startuml

skinparam dpi 150 

interface BlockingQueue<E> {
  void put(E e) throws InterruptedException;
  E take() throws InterruptedException;
}

class ArrayBlockingQueue<E>
class LinkedBlockingDeque<E>
class PriorityBlockingQueue<E>
class SynchronousQueue<E>

BlockingQueue <|.. ArrayBlockingQueue
BlockingQueue <|.. LinkedBlockingDeque
BlockingQueue <|.. PriorityBlockingQueue
BlockingQueue <|.. SynchronousQueue
@enduml
----

* Могут быть ограничены по размеру (capacity constrained).
* Методы `put()` и `take()` ждут, пока не появится возможность положить или взять элемент.
* `PriorityBlockingQueue` не лимитируется по capacity.
* `SynchronousQueue` не имеет capacity вовсе, передаёт элементы обрабатывающим тредам напрямую. 

== ConcurrentHashMap

[source,java]
----
class ConcurrentHashMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentMap<K,V>
----
* Замена `HashMap` при разделённом доступе к данным.
* Не блокируется при чтении и редко блокируется при записи.
* Не позволяет использовать `null` в качестве ключа или значения.
* Полезные методы атомарны:
** `putIfAbsent(key, value)`
** `remove(key, value)`
** `replace(key, oldValue, newValue)`

== ConcurrentHashMap: Java 7-

[graphviz]
--
digraph Java {
n382319160[label="ConcurrentHashMap|{segmentMask: 7|segmentShift: 29|keySet: null|entrySet: null|values: null}",shape=record];
n382319160 -> n521751118[label="segments",fontsize=12];
n521751118[label="<f0>|<f1>|<f2>|<f3>|<f4>|<f5>|<f6>|<f7>",shape=record];
n521751118:f0 -> n564898696[label="0",fontsize=12];
n564898696[label="Segment|{count: 0|modCount: 0|threshold: 1|loadFactor: 0.75}",shape=record];
n564898696 -> n1981440623[label="table",fontsize=12];
n1981440623[shape=record, label="null|null"];
n521751118:f1 -> n1043636732[label="1",fontsize=12];
n1043636732[label="Segment|{count: 2|modCount: 2|threshold: 1|loadFactor: 0.75}",shape=record];
n1043636732 -> n1903609675[label="table",fontsize=12];
n1903609675[label="<f0>|<f1>",shape=record];
n1903609675:f0 -> n295131993[label="0",fontsize=12];
n295131993[label="HashEntry|{key: five|hash: 553292222|value: 5|next: null}",shape=record];
n1903609675:f1 -> n1743665428[label="1",fontsize=12];
n1743665428[label="HashEntry|{key: three|hash: 1047845927|value: 3|next: null}",shape=record];
n521751118:f2 -> n1419115801[label="2",fontsize=12];
n1419115801[label="Segment|{count: 0|modCount: 0|threshold: 1|loadFactor: 0.75}",shape=record];
n1419115801 -> n1125883825[label="table",fontsize=12];
n1125883825[shape=record, label="null|null"];
n521751118:f3 -> n1251033058[label="3",fontsize=12];
n1251033058[label="Segment|{count: 2|modCount: 2|threshold: 1|loadFactor: 0.75}",shape=record];
n1251033058 -> n100218029[label="table",fontsize=12];
n100218029[label="<f0>|<f1>",shape=record];
n100218029:f0 -> n737234155[label="0",fontsize=12];
n737234155[label="HashEntry|{key: one|hash: 1919294914|value: 1|next: null}",shape=record];
n100218029:f1 -> n1861283542[label="1",fontsize=12];
n1861283542[label="HashEntry|{key: four|hash: 1850787001|value: 4|next: null}",shape=record];
n521751118:f4 -> n476651318[label="4",fontsize=12];
n476651318[label="Segment|{count: 0|modCount: 0|threshold: 1|loadFactor: 0.75}",shape=record];
n476651318 -> n183062162[label="table",fontsize=12];
n183062162[shape=record, label="null|null"];
n521751118:f5 -> n1529174230[label="5",fontsize=12];
n1529174230[label="Segment|{count: 1|modCount: 1|threshold: 1|loadFactor: 0.75}",shape=record];
n1529174230 -> n1894479961[label="table",fontsize=12];
n1894479961[label="<f0>|<f1>",shape=record];
n1894479961:f0 -> n1932154105[label="0",fontsize=12];
n1932154105[label="HashEntry|{key: two|hash: -1406597098|value: 2|next: null}",shape=record];
n521751118:f6 -> n1613816448[label="6",fontsize=12];
n1613816448[label="Segment|{count: 0|modCount: 0|threshold: 1|loadFactor: 0.75}",shape=record];
n1613816448 -> n694579926[label="table",fontsize=12];
n694579926[shape=record, label="null|null"];
n521751118:f7 -> n332181545[label="7",fontsize=12];
n332181545[label="Segment|{count: 0|modCount: 0|threshold: 1|loadFactor: 0.75}",shape=record];
n332181545 -> n1665228262[label="table",fontsize=12];
n1665228262[shape=record, label="null|null"];
}
--

== ConcurrentHashMap: Java 8+

[graphviz]
--
digraph Java {
	rankdir="TB";
	node[shape=plaintext];
	graph [ dpi = 120 ];
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>ConcurrentHashMap</td>
			</tr>
			<tr>
				<td>sizeCtl: 24</td>
			</tr>
			<tr>
				<td>cellsBusy: 0</td>
			</tr>
			<tr>
				<td>transferIndex: 0</td>
			</tr>
			<tr>
				<td>baseCount: 5</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0' cellpadding='9'>
			<tr>
				<td port="f0"></td>
				<td port="f1"></td>
				<td port="f2"></td>
				<td port="f3"></td>
				<td port="f4"></td>
				<td port="f5"></td>
				<td port="f6"></td>
				<td port="f7"></td>
				<td port="f8"></td>
				<td port="f9"></td>
				<td port="f10"></td>
				<td port="f11"></td>
				<td port="f12"></td>
				<td port="f13"></td>
				<td port="f14"></td>
				<td port="f15"></td>
				<td port="f16"></td>
				<td port="f17"></td>
				<td port="f18"></td>
				<td port="f19"></td>
				<td port="f20"></td>
				<td port="f21"></td>
				<td port="f22"></td>
				<td port="f23"></td>
				<td port="f24"></td>
				<td port="f25"></td>
				<td port="f26"></td>
				<td port="f27"></td>
				<td port="f28"></td>
				<td port="f29"></td>
				<td port="f30"></td>
				<td port="f31"></td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Node</td>
			</tr>
			<tr>
				<td>val: 1</td>
			</tr>
			<tr>
				<td>hash: 110183</td>
			</tr>
			<tr>
				<td>key: one</td>
			</tr>
		</table>
	>];
	n2:f7 -> n3[label="7",fontsize=12];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Node</td>
			</tr>
			<tr>
				<td>val: 2</td>
			</tr>
			<tr>
				<td>hash: 115277</td>
			</tr>
			<tr>
				<td>key: two</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Node</td>
			</tr>
			<tr>
				<td>val: 3</td>
			</tr>
			<tr>
				<td>hash: 110338829</td>
			</tr>
			<tr>
				<td>key: three</td>
			</tr>
		</table>
	>];
	n4 -> n5[label="next",fontsize=12];
	n2:f13 -> n4[label="13",fontsize=12];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Node</td>
			</tr>
			<tr>
				<td>val: 4</td>
			</tr>
			<tr>
				<td>hash: 3149078</td>
			</tr>
			<tr>
				<td>key: four</td>
			</tr>
		</table>
	>];
	n2:f22 -> n6[label="22",fontsize=12];
	n7[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Node</td>
			</tr>
			<tr>
				<td>val: 5</td>
			</tr>
			<tr>
				<td>hash: 3143325</td>
			</tr>
			<tr>
				<td>key: five</td>
			</tr>
		</table>
	>];
	n2:f29 -> n7[label="29",fontsize=12];
	n1 -> n2[label="table",fontsize=12];
}
--

== ConcurrentSkipListMap

[source,java]
----
class ConcurrentSkipListMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentNavigableMap<K,V>
----
* Замена `TreeMap` при разделённом доступе к данным.
* Не позволяет использовать `null` в качестве ключа или значения.
* Имеет атомарные методы.

== ConcurrentSkipListMap: идея
[graphviz]
--
digraph G {
    rankdir = LR;
    node[shape=box,label=""];
    I1->I2->I3->IF[label=right];
    II1->II2->II3->II4->II5->II6->IIF[label=right];
    N00->N01->N02->N03->N04->N05->N06->N07->N08->N09->N10->N11->NF[label=next];
    I1->II1->N00[label="                   down"];
    II2->N03[label="                   down"];
    I2->II3->N04[label="                   down"];
    II4->N06[label="                   down"];
    I3->II5->N09[label="                   down"];
    II6->N11[label="                   down"];
    {rank=same;I1;II1;N00}
    {rank=same;II2;N03}
    {rank=same;I2;II3;N04}
    {rank=same;II4;N06}
    {rank=same;I3;II5;N09}
    {rank=same;II6;N11}
    IF[shape=oval,label="null"];
    IIF[shape=oval,label="null"];
    NF[shape=oval,label="null"];
    N01[label="A"]; N02[label="B"]; N03[label="C"];
    N04[label="D"]; N05[label="E"]; N06[label="F"];
    N07[label="G"]; N08[label="H"]; N09[label="I"];
    N10[label="J"]; N11[label="K"]; 
}
--



== ConcurrentSkipListMap

//A

[graphviz]
--
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>ConcurrentSkipListMap</td>
			</tr>
			<tr>
				<td>adder: 1</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Node</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: A</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n3 -> n4[label="next",fontsize=12];
	n2 -> n3[label="node",fontsize=12,constraint=false,color=green];
	n1 -> n2[label="head",fontsize=12];
}

--

== ConcurrentSkipListMap

[graphviz]
--
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>ConcurrentSkipListMap</td>
			</tr>
			<tr>
				<td>adder: 2</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Node</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: A</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: B</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n4 -> n5[label="next",fontsize=12];
	n3 -> n4[label="next",fontsize=12];
	n2 -> n3[label="node",fontsize=12,constraint=false,color=green];
	n1 -> n2[label="head",fontsize=12];
}

--

== ConcurrentSkipListMap

[graphviz]
--
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>ConcurrentSkipListMap</td>
			</tr>
			<tr>
				<td>adder: 3</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: C</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n4 -> n5[label="node",fontsize=12,constraint=false,color=green];
	n3 -> n4[label="right",fontsize=12];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Node</td>
			</tr>
		</table>
	>];
	n7[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: A</td>
			</tr>
		</table>
	>];
	n8[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: B</td>
			</tr>
		</table>
	>];
	n8 -> n5[label="next",fontsize=12];
	n7 -> n8[label="next",fontsize=12];
	n6 -> n7[label="next",fontsize=12];
	n3 -> n6[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n3[label="down",fontsize=12,constraint=false];
	n9[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n9 -> n4[label="down",fontsize=12,constraint=false];
	n9 -> n5[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n9[label="right",fontsize=12];
	n2 -> n6[label="node",fontsize=12,constraint=false,color=green];
	n1 -> n2[label="head",fontsize=12];
}

--

== ConcurrentSkipListMap

[graphviz]
--
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>ConcurrentSkipListMap</td>
			</tr>
			<tr>
				<td>adder: 4</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: D</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n5 -> n6[label="node",fontsize=12,constraint=false,color=green];
	n4 -> n5[label="right",fontsize=12];
	n7[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: C</td>
			</tr>
		</table>
	>];
	n7 -> n6[label="next",fontsize=12];
	n4 -> n7[label="node",fontsize=12,constraint=false,color=green];
	n3 -> n4[label="right",fontsize=12];
	n8[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Node</td>
			</tr>
		</table>
	>];
	n9[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: A</td>
			</tr>
		</table>
	>];
	n10[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: B</td>
			</tr>
		</table>
	>];
	n10 -> n7[label="next",fontsize=12];
	n9 -> n10[label="next",fontsize=12];
	n8 -> n9[label="next",fontsize=12];
	n3 -> n8[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n3[label="down",fontsize=12,constraint=false];
	n11[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n11 -> n4[label="down",fontsize=12,constraint=false];
	n11 -> n7[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n11[label="right",fontsize=12];
	n2 -> n8[label="node",fontsize=12,constraint=false,color=green];
	n1 -> n2[label="head",fontsize=12];
}

--

== ConcurrentSkipListMap

[graphviz]
--
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>ConcurrentSkipListMap</td>
			</tr>
			<tr>
				<td>adder: 5</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n7[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: E</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n6 -> n7[label="node",fontsize=12,constraint=false,color=green];
	n5 -> n6[label="right",fontsize=12];
	n8[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: D</td>
			</tr>
		</table>
	>];
	n8 -> n7[label="next",fontsize=12];
	n5 -> n8[label="node",fontsize=12,constraint=false,color=green];
	n4 -> n5[label="right",fontsize=12];
	n9[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: C</td>
			</tr>
		</table>
	>];
	n9 -> n8[label="next",fontsize=12];
	n4 -> n9[label="node",fontsize=12,constraint=false,color=green];
	n3 -> n4[label="right",fontsize=12];
	n10[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Node</td>
			</tr>
		</table>
	>];
	n11[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: A</td>
			</tr>
		</table>
	>];
	n12[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: B</td>
			</tr>
		</table>
	>];
	n12 -> n9[label="next",fontsize=12];
	n11 -> n12[label="next",fontsize=12];
	n10 -> n11[label="next",fontsize=12];
	n3 -> n10[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n3[label="down",fontsize=12,constraint=false];
	n13[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n13 -> n4[label="down",fontsize=12,constraint=false];
	n13 -> n9[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n13[label="right",fontsize=12];
	n2 -> n10[label="node",fontsize=12,constraint=false,color=green];
	n1 -> n2[label="head",fontsize=12];
}
--

== ConcurrentSkipListMap

[graphviz]
--
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>ConcurrentSkipListMap</td>
			</tr>
			<tr>
				<td>adder: 6</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n7[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n8[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: F</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n7 -> n8[label="node",fontsize=12,constraint=false,color=green];
	n6 -> n7[label="right",fontsize=12];
	n9[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: E</td>
			</tr>
		</table>
	>];
	n9 -> n8[label="next",fontsize=12];
	n6 -> n9[label="node",fontsize=12,constraint=false,color=green];
	n5 -> n6[label="right",fontsize=12];
	n10[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: D</td>
			</tr>
		</table>
	>];
	n10 -> n9[label="next",fontsize=12];
	n5 -> n10[label="node",fontsize=12,constraint=false,color=green];
	n4 -> n5[label="right",fontsize=12];
	n11[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: C</td>
			</tr>
		</table>
	>];
	n11 -> n10[label="next",fontsize=12];
	n4 -> n11[label="node",fontsize=12,constraint=false,color=green];
	n3 -> n4[label="right",fontsize=12];
	n12[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Node</td>
			</tr>
		</table>
	>];
	n13[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: A</td>
			</tr>
		</table>
	>];
	n14[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: B</td>
			</tr>
		</table>
	>];
	n14 -> n11[label="next",fontsize=12];
	n13 -> n14[label="next",fontsize=12];
	n12 -> n13[label="next",fontsize=12];
	n3 -> n12[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n3[label="down",fontsize=12,constraint=false];
	n15[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n15 -> n4[label="down",fontsize=12,constraint=false];
	n15 -> n11[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n15[label="right",fontsize=12];
	n2 -> n12[label="node",fontsize=12,constraint=false,color=green];
	n1 -> n2[label="head",fontsize=12];
}

--

== ConcurrentSkipListMap

[graphviz]
--
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>ConcurrentSkipListMap</td>
			</tr>
			<tr>
				<td>adder: 7</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n7[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n8[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n9[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: G</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n8 -> n9[label="node",fontsize=12,constraint=false,color=green];
	n7 -> n8[label="right",fontsize=12];
	n10[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: F</td>
			</tr>
		</table>
	>];
	n10 -> n9[label="next",fontsize=12];
	n7 -> n10[label="node",fontsize=12,constraint=false,color=green];
	n6 -> n7[label="right",fontsize=12];
	n11[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: E</td>
			</tr>
		</table>
	>];
	n11 -> n10[label="next",fontsize=12];
	n6 -> n11[label="node",fontsize=12,constraint=false,color=green];
	n5 -> n6[label="right",fontsize=12];
	n12[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: D</td>
			</tr>
		</table>
	>];
	n12 -> n11[label="next",fontsize=12];
	n5 -> n12[label="node",fontsize=12,constraint=false,color=green];
	n4 -> n5[label="right",fontsize=12];
	n13[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: C</td>
			</tr>
		</table>
	>];
	n13 -> n12[label="next",fontsize=12];
	n4 -> n13[label="node",fontsize=12,constraint=false,color=green];
	n3 -> n4[label="right",fontsize=12];
	n14[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Node</td>
			</tr>
		</table>
	>];
	n15[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: A</td>
			</tr>
		</table>
	>];
	n16[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: B</td>
			</tr>
		</table>
	>];
	n16 -> n13[label="next",fontsize=12];
	n15 -> n16[label="next",fontsize=12];
	n14 -> n15[label="next",fontsize=12];
	n3 -> n14[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n3[label="down",fontsize=12,constraint=false];
	n17[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n17 -> n4[label="down",fontsize=12,constraint=false];
	n18[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n18 -> n8[label="down",fontsize=12,constraint=false];
	n18 -> n9[label="node",fontsize=12,constraint=false,color=green];
	n17 -> n18[label="right",fontsize=12];
	n17 -> n13[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n17[label="right",fontsize=12];
	n2 -> n14[label="node",fontsize=12,constraint=false,color=green];
	n1 -> n2[label="head",fontsize=12];
}

--

== ConcurrentSkipListMap

[graphviz]
--
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>ConcurrentSkipListMap</td>
			</tr>
			<tr>
				<td>adder: 8</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n7[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n8[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n9[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: G</td>
			</tr>
		</table>
	>];
	n10[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: H</td>
			</tr>
		</table>
	>,style=filled,fillcolor=yellow];
	n9 -> n10[label="next",fontsize=12];
	n8 -> n9[label="node",fontsize=12,constraint=false,color=green];
	n7 -> n8[label="right",fontsize=12];
	n11[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: F</td>
			</tr>
		</table>
	>];
	n11 -> n9[label="next",fontsize=12];
	n7 -> n11[label="node",fontsize=12,constraint=false,color=green];
	n6 -> n7[label="right",fontsize=12];
	n12[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: E</td>
			</tr>
		</table>
	>];
	n12 -> n11[label="next",fontsize=12];
	n6 -> n12[label="node",fontsize=12,constraint=false,color=green];
	n5 -> n6[label="right",fontsize=12];
	n13[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: D</td>
			</tr>
		</table>
	>];
	n13 -> n12[label="next",fontsize=12];
	n5 -> n13[label="node",fontsize=12,constraint=false,color=green];
	n4 -> n5[label="right",fontsize=12];
	n14[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: C</td>
			</tr>
		</table>
	>];
	n14 -> n13[label="next",fontsize=12];
	n4 -> n14[label="node",fontsize=12,constraint=false,color=green];
	n3 -> n4[label="right",fontsize=12];
	n15[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Node</td>
			</tr>
		</table>
	>];
	n16[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: A</td>
			</tr>
		</table>
	>];
	n17[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>key: B</td>
			</tr>
		</table>
	>];
	n17 -> n14[label="next",fontsize=12];
	n16 -> n17[label="next",fontsize=12];
	n15 -> n16[label="next",fontsize=12];
	n3 -> n15[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n3[label="down",fontsize=12,constraint=false];
	n18[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n18 -> n4[label="down",fontsize=12,constraint=false];
	n19[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n19 -> n8[label="down",fontsize=12,constraint=false];
	n19 -> n9[label="node",fontsize=12,constraint=false,color=green];
	n18 -> n19[label="right",fontsize=12];
	n18 -> n14[label="node",fontsize=12,constraint=false,color=green];
	n2 -> n18[label="right",fontsize=12];
	n2 -> n15[label="node",fontsize=12,constraint=false,color=green];
	n1 -> n2[label="head",fontsize=12];
}

--

== Часть 4. Executor Framework

image::hydra2.jpg[{image-90-width}]

== Executor Framework

* Тред -- дорогой ресурс, поэтому мы хотим:
** ограничивать количество наших тредов, чтобы не устроить Out of Memory,
** переиспользовать имеющиеся треды, подавая им новые задачи после завершения старых,
** но если какой-то тред «вылетел» -- автоматически создавать новый.
* В стандартной библиотеке для этого есть Thread Pools, не надо ничего делать самостоятельно.
* Никто не использует Thread API напрямую.

== Executor Framework

[source,java]
----
//Абстракция вычислительной задачи, возвращающей результат
public interface Callable<V> {
  V call() throws Exception;
}

//Абстракция «менджера тредов»
public interface ExecutorService {
  <T> Future<T> submit(Callable<T> task);
  /*...есть и много другого, речь впереди...*/
}
----

== Future

[source,java]
----
//Абстракция результата "in progress", который можно ждать, 
//а можно и отменить
public interface Future<V> {
  V get() throws InterruptedException, ExecutionException;
  V get(long timeout, TimeUnit unit)
    throws InterruptedException, ExecutionException, TimeoutException;
  boolean cancel(boolean mayInterruptIfRunning);
  boolean isDone();
  boolean isCancelled();
}
----

== Task, Executor, Future

[plantuml, taskexecfuture, png]
----
@startuml
skinparam dpi 150
hide footbox

participant Client
participant Task
participant Executor
participant Future

Client -> Task **: new()
Task --> Client: task

Client -> Executor: submit(task)
Executor -> Future **: new(task)
Future --> Executor: Future
Executor --> Client: Future 

Executor -> Future: run()
note right
  в отдельном потоке
  выполнения
end note

Future -> Task: call()
activate Task

Client -> Future: get()
activate Future
Task --> Future: result
deactivate Task
Future --> Client: result
deactivate Future

@enduml
----

== Как создать ExecutorService?

[source,java]
----
public class  Executors {
  //фиксированный размер пула
  public static ExecutorService newFixedThreadPool(int nThreads)
  public static ExecutorService newSingleThreadExecutor()
  //пул растёт по необходимости, держит неактивный тред 60 секунд
  public static ExecutorService newCachedThreadPool()
  //позволяет выполнять задачи с задержкой или периодичностью
  public static 
    ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
  ...
}
----

== Обработка задач «пачками»
[source,java]
----
//Запускаем и ждём, пока все выполнятся
//List<Future<T>>, а не List<T>, т. к. возможны исключения
<T> List<Future<T>> invokeAll(
    Collection<? extends Callable<T>> tasks)
        throws InterruptedException

//Запускаем, возвращаем первый успешный результат, 
//отменяем остальные
<T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;
----

== Отмена задач и «прекращение обслуживания»

[source,java]
----
//отменить задачу, если она ещё не начала выполняться
future.cancel(false)
//запросить прерывание задачи (подробности впереди)
future.cancel(true)

//Запретить приём новых задач
executorService.shutdown();
//Подождать, пока принятые задачи завершатся
if (!service.awaitTermination(10, TimeUnit.SECONDS)){
    //Прервать выполнение задач
    service.shutdownNow();
}
----

== Прерывание задач

* В ранних версиях Java существовали (ныне deprecated) методы принудительной остановки и приостановки/возобновления тредов, но _это оказалось плохой идеей:_
** нет гарантий, что тред не остановится посередине атомарной операции.
** приостановка может на неопределённое время "завесить" блокировку
* В итоге, имеется _кооперативный_ механизм прерывания.

== Прерывание тредов

* `ExecutorService.shutdownNow()` вызывает метод `Thread.interrupt()` на потоках выполнения.
* метод `Thread.isInterrupted()` возвращает статус прерывания треда.
* *JMM Interruption Rule*: вызов метода `interrupt()` внешним потоком _happens-before_ прерываемый поток узнаёт о том, что он прерван.

== Кооперативный механизм прерывания

* Если вычисления в цикле, тред обязан периодически проверять статус `Thread.currentThread().isInterrupted()` и, если флаг выставлен, _записав в лог факт прерывания_, выходить из метода.

* На ждущих методах может быть выброшен `InterruptedException`. Что с ним делать?

== Что делать с `InterruptedException`

* Если контекст позволяет, его всегда следует пробрасывать выше (декларируя в `throws`).

* Если выше пробрасывать нельзя (например, мы находимся в методе `run` интерфейса `Runnable`), то: 

[source,java]
----
} catch (InterruptedException e) {
    //записываем факт прерывания в лог ...
    ...
    //восстанавливаем interrupted-статус
    Thread.currentThread().interrupt();
    //выходим из прерванной процедуры
    return;
}
----
* Просто так "проглатывать" `InterruptedException` *ни в коем случае нельзя*!
* Рекомендуется записывать факт прерывания в лог, для прозрачности отладки.

== CompletableFuture

* Появились в Java 8, расширяют `Future`.
* Позволяют явно задать результат (отсюда 'Completable') и собрать цепочку асинхронных вычислений.
* Могут быть использованы так: 

[source,java]
----
CompletableFuture<Integer> f = new CompletableFuture<>();
executor.execute(() -> {
  int n = workHard(arg);
  f.complete(n); });
  
executor.execute(() -> {
  int n = workSmart(arg);
  f.complete(n); });

executor.execute(() -> {
  Throwable t = ...;
  f.completeExceptionally(t); });
----

== Композиция CompletableFuture с действием

[cols="20a,20a,60a"]
|===
|*Method*            |*Parameter*            |*Description*
|`thenApply`         |T->U                   |Apply a function to the result.
|`thenAccept`        |T->void                |Like `thenApply`, but with `void` result.
|`thenCompose`       |T->CompletableFuture<U>|Invoke the function on the result and execute the returned future.
|`handle`            |(T, Throwable) -> U    |Process the result or error and yield a new result.
|`whenComplete`      |(T, Throwable) -> void |Like `handle`, but with `void` result.
|===


== Композиция CompletableFuture с действием

[cols="20a,20a,60a"]
|===
|*Method*            |*Parameter*            |*Description*
|`completeOnTimeout` |T, long, TimeUnit      |Yield the given value as the result in case of timeout (Java 9+)
|`orTimeout`         |long, TimeUnit         |Throw `TimeoutException ` in case of timeout (Java 9+) 
|`thenRun`           |Runnable               |Execute the `Runnable` with void result.
|===

== Композиция нескольких CompletableFuture

[cols="20a,20a,60a"]
|===
|*Method*            |*Parameter*            |*Description*
|`thenCombine`       |ComletableFuture<U>, +
                      (T, U)->V              |Execute both and combine the results with the given function.
|`thenAcceptBoth`    |ComletableFuture<U>, +
                      (T, U)->void           |Like `thenCombine`, but with `void` result.
|`runAfterBoth`      |CompletableFuture<?>, +
                      Runnable               |Execute the runnable after both complete.
|===

== Композиция нескольких CompletableFuture
[cols="20a,20a,60a"]
|===
|*Method*            |*Parameter*            |*Description*
|`applyToEither`     |CompletableFuture<T>, +
                      T->V                   |When a result is available from one or the other, pass it to the given function.
|`acceptEither`      |CompletableFuture<T>, +
                      T->void                |Like `applyToEither`, but with `void` result.
|`runAfterEither`    |CompletableFuture<?>, +
                      Runnable               |Execute the runnable after one or the other completes.
|`static allOf`      |CompletableFuture<?>...|Complete with `void` result after all given futeres complete.
|`static anyOf`      |CompletableFuture<?>...|Complete after any of the given futures completes, with the same result cast to `Object`.
|===

== Если этого показалось мало...
* Каждый из этих методов имеет вариант с постфиксом `Async` (например, `thenApplyAsync`), позволяющий выполнить дополнительное действие в другом треде заданного Executor-a.

== Мы только прошлись по основам

[cols="30a,70a"]
|===
|image::jcip.jpg[]| 
* *Brian Goetz et al.*, Java Concurrency in Practice.
* Вышла в 2006-м году, в эпоху Java 5.0.
* Новых изданий не выходило.
* На русском языке вышла в 2020-м году!
* Всё ещё самое полное руководство по разным аспектам многопоточного программирования на Java.
|===

== Code Review Checklist

* *Roman Leventov*: https://github.com/code-review-checklists/java-concurrency[Code Review Checklist: Java Concurrency]

* Порядка 100 пунктов, по которым можно проверить concurrency код на распространённые ошибки



== Благодарности 

Эти люди дали свой фидбэк и помогли улучшить материал этой лекции:

icon:twitter[size=lg]@2caco3
icon:twitter[size=lg]@asm0dey
icon:twitter[size=lg]@dolzhenko
icon:twitter[size=lg]@DrEdwardHyde

icon:twitter[size=lg]@dyer_the
icon:twitter[size=lg]@krems5
icon:twitter[size=lg]@LordOfBoredom

icon:twitter[size=lg]@miha_x64
icon:twitter[size=lg]@vaddyacom
icon:twitter[size=lg]@vdimir


(все ошибки и неточности -- мои)


== Иногда при чтении кода начинает рябить в глазах...

[source,java]
----
import org.json.JSONObject;
class NaivePersonSerializer {
  String toJSON(Person person) {
    JSONObject result = new JSONObject();
      result.put("firstName", person.getFirstName());
      result.put("lastName", person.getLastName());
      result.put("birthDate",
        person.getBirthDate()
        .format(DateTimeFormatter.ISO_LOCAL_DATE));
      result.put(...)
      result.put(...)
      //ещё 20 полей
      result.put(...)
      return result.toString();
  }
}
----

== Возникает ощущение, что что-то не так...

[source,java]
----
public class NaiveController {
  private final Service service;
  public void executeCommand(String command) {
    switch (command) {
      case "foo":
        service.foo(); break;
      case "bar":
        service.bar(); break;
      case ...
      //Ещё 15 веток...
      case "help":
      default:
        service.help(); break;
    }
  }
}
----

== Coupling & Cohesion

* Coupling: the degree of interdependence between software modules; a measure of how closely connected two routines or modules are; the strength of the relationships between modules.

* Cohesion refers to the degree to which the elements inside a module belong together.

* Low coupling often correlates with high cohesion, and vice versa.

== Coupling vs. Cohesion

image::coupling-cohesion.png[{image-70-width}]


== Вопросы

* За счёт чего в приведённых примерах high coupling + low cohesion?
* Чем это опасно для проекта?

== Как бы мы хотели решить эту проблему?

[source,java]
----
//Помечаем то, что хотим сериализовывать, не сериализуем по умолчанию.
//Вариант: наоборот, помечать то, что сериализовывать не хотим.
public class Person {
    @Published
    private final String firstName;
    @Published
    private final String lastName;
    @Published
    private final LocalDate birthDate;
    //...сколько угодно ещё полей
}

//Как вариант...
JsonSerializer<Person> ser = new JsonSerializer<>(Person.class);
JSONObject json = ser.serialize(p);
----

== Контроллер
[source,java]
----
public class Controller {
  private final Service service;

  @Command("foo")
  void doSomething() { service.foo(); }

  @Command("bar")
  void bar() { service.bar(); }
  
  //ещё 15 команд

  @Command() //дефолтная
  void help() { service.help(); }
}

new CommandDispatcher(new Controller(srv)).executeCommand("foo");
----

== Аннотации

* Аннотация -- способ разметки кода на Java, через добавление метаинформации к различным элементам программы на Java.
* Работают приблизительно как модификаторы (`public`, `static`), но существует развитый механизм создания собственных аннотаций.
* Могут быть обработаны на трёх этапах:
** на этапе кодогенерации перед компиляцией (annotation processing, Language Model API),
** на этапе инструментации байт-кода (Instrumentation API),
** на этапе выполнения кода (через Reflection API).

== Синтаксис определения аннотаций

----
modifiers @interface AnnotationName {
  type elementName();
  ...
  type elementName default value;
}
----

== Пример
[source,java]
----
public @interface BugReport {
  String assignedTo() default "";
  int severity();
}
----
== Annotation Interfaces

* Подобно тому, как `enum`-классы -- это специальный вид классов, annotation-интерфейсы -- это специальный вид интерфейсов.
* Наследуются от `java.lang.annotation.Annotation`.
* Нельзя расширять наследованием, нельзя параметризовать через generics.
* Методы не могут иметь параметров.

== Допустимые типы методов аннотации (JLS 9.6.1)

* Примитивы (`int`, `short`, `long`, `byte`, `char`, `double`, `float`, `boolean`),
* enum-ы,
* `String`,
* `Class` (с возможным ограничителем параметра, вроде `Class<? extends MyClass>`),
* другие аннотации,
* массивы из вышеперечисленного (но не массивы массивов).

== Пример определения интерфейса аннотации

[source,java]
----
public @interface BugReport {
  //вложенные типы допустимы!
  enum Status {UNCONFIRMED, CONFIRMED, FIXED, NOTABUG}
  boolean showStopper() default false;
  String assignedTo() default "";
  
  //метакласс, речь впереди
  Class<?> testCase() default Void.class;
  Status status() default Status.UNCONFIRMED;
  
  //Тип аннотации. При конструировании используется синтаксис
  //аннотации, речь впереди
  Reference ref() default @Reference(id = "");
  String[] reportedBy();
}
----

== Использование аннотаций

----
@AnnotationName(elementName1=value1, elementName2=value2,...)

@AnnotationName(singleValue)

@AnnotationName //no values, no parens
----

== Использование аннотаций

[source,java]
----
@BugReport(assignedTo="Harry", severity=10)

//порядок не имеет значения
@BugReport(severity=10, assignedTo="Harry")

//если заданы значения по умолчанию, то можно пропускать
@BugReport(severity=10)

//если параметров нет или все имеют умолчания, 
//то можно не ставить скобки
@BugReport

//Если на параметр не задан default, его надо  обязательно определять 
//(иначе ошибка компиляции).
----

== Single-value annotations

[source,java]
----
public @interface ActionListenerFor {
  String value();
  int priority() default 0;
}

//использование
@ActionListenerFor("yellowButton")

//что эквивалентно
@ActionListenerFor(value = "yellowButton")

//в то же время:
@ActionListenerFor(value = "yellowButton", priority = 1)
----



== Массивы и другие аннотации

[source,java]
----
//Массивы задаются в фигурных скобках
@BugReport(..., reportedBy = {"Harry", "Carl"})

//То же самое, что {"Harry"}
@BugReport(..., reportedBy = "Harry")

//Конструирование вложенных аннотаций
@BugReport(..., ref = @Reference(id = "12345"))

//...Как видим, используя разрешённые типы,
//можно задать сколь угодно сложную структуру данных
----

WARNING: Значение аннотации не может быть установлено в `null`. Не допускатся `null` даже в `default`-значениях. 


