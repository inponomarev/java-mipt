msgid ""
msgstr ""
"Project-Id-Version: slides 09\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-20 21:26+0300\n"
"PO-Revision-Date: 2023-02-20 21:30+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: en_UK\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.2.2\n"

#: lecture.adoc:24
msgid ""
"= Core Java. Лекция 9: Streams API, Optionals\n"
"Иван Пономарёв, КУРС/МФТИ\n"
":revealjs_theme: black\n"
":revealjs_customtheme: white_course.css\n"
":revealjs_slideNumber:\n"
":revealjs_history:\n"
":revealjs_progress:\n"
":encoding: UTF-8\n"
":lang: ru\n"
"include::_doc_general_attributes.adoc[]\n"
":doctype: article\n"
":toclevels: 3\n"
":imagesdir: images\n"
":source-highlighter: highlightjs\n"
":highlightjsdir: highlight\n"
":icons: font\n"
":iconfont-remote!:\n"
":iconfont-name: font-awesome-4.7.0/css/font-awesome\n"
":revealjs_mouseWheel: true\n"
":revealjs_center: false\n"
":revealjs_transition: none\n"
":revealjs_width: 1600\n"
":revealjs_height: 900"
msgstr ""
"= Core Java. Lecture #9: Streams API, Optionals\n"
"Ivan Ponomarev, Synthesized.io/MIPT\n"
":revealjs_theme: black\n"
":revealjs_customtheme: white_course.css\n"
":revealjs_slideNumber:\n"
":revealjs_history:\n"
":revealjs_progress:\n"
":encoding: UTF-8\n"
":lang: ru\n"
"include::_doc_general_attributes.adoc[]\n"
":doctype: article\n"
":toclevels: 3\n"
":imagesdir: images\n"
":source-highlighter: highlightjs\n"
":highlightjsdir: highlight\n"
":icons: font\n"
":iconfont-remote!:\n"
":iconfont-name: font-awesome-4.7.0/css/font-awesome\n"
":revealjs_mouseWheel: true\n"
":revealjs_center: false\n"
":revealjs_transition: none\n"
":revealjs_width: 1600\n"
":revealjs_height: 900"

#: lecture.adoc:27
msgid ":!figure-caption:"
msgstr ":!figure-caption:"

#: lecture.adoc:29
msgid "ponomarev@corchestra.ru"
msgstr "ponomarev@corchestra.ru"

#: lecture.adoc:31
msgid "icon:twitter[size=lg] @inponomarev"
msgstr "icon:twitter[size=lg] @inponomarev"

#: lecture.adoc:33
msgid "== Streams"
msgstr "== Streams"

#: lecture.adoc:38
msgid ""
"* Появились в Java8, вместе с lambdas & method references.\n"
"* Обработка конечных и потенциально бесконечных наборов данных.\n"
"* Декларативный подход к обработке данных: описываем *что* хотим получить, а "
"не *как* мы это получим.\n"
"* Прозрачный параллелизм."
msgstr ""
"* Appeared in Java8, along with lambdas & method references.\n"
"* Process finite and potentially infinite data sets.\n"
"* Declarative approach to data processing: we describe *what* we want to "
"get, not *how* we will get it.\n"
"* Transparent parallelism."

#: lecture.adoc:40
msgid "== Преобразуем поток в поток"
msgstr "== Convert stream to stream"

#: lecture.adoc:43
msgctxt "lecture.adoc:43"
msgid ""
"[cols=\"^40a,60a\"]\n"
"|==="
msgstr ""
"[cols=\"^40a,60a\"]\n"
"|==="

#: lecture.adoc:46
msgid ""
"|\n"
"`blockStream`"
msgstr ""
"|\n"
"`blockStream`"

#: lecture.adoc:48
msgid "image::map.svg[]"
msgstr "image::map.svg[]"

#: lecture.adoc:53
msgid ""
"`squashedStream`\n"
"|[source,java]\n"
"----\n"
"List<Block> blocks = ...;"
msgstr ""
"`squashedStream`\n"
"|[source,java]\n"
"----\n"
"List<Block> blocks = ...;"

#: lecture.adoc:55
msgid "Stream<Block> blocksStream = blocks.stream();"
msgstr "Stream<Block> blocksStream = blocks.stream();"

#: lecture.adoc:59
msgid ""
"Stream<SquashedBlock> squashedStream =\n"
"  blocksStream.map(Block::squash);\n"
"----"
msgstr ""
"Stream<SquashedBlock> squashedStream =\n"
"  blocksStream.map(Block::squash);\n"
"----"

#: lecture.adoc:62
msgid ""
"(Автор анимаций -- Тагир Валеев, движущиеся картинки см. https://"
"stackoverflow.com/questions/35150231/java-streams-lazy-vs-fusion-vs-short-"
"circuiting[здесь])\n"
"|==="
msgstr ""
"(The author of the animations is Tagir Valeev, see moving pictures https://"
"stackoverflow.com/questions/35150231/java-streams-lazy-vs-fusion-vs-short-"
"circuiting[here])\n"
"|==="

#: lecture.adoc:65
msgid "== Фильтруем"
msgstr "== Filtering"

#: lecture.adoc:68
msgctxt "lecture.adoc:68"
msgid ""
"[cols=\"^40a,60a\"]\n"
"|==="
msgstr ""
"[cols=\"^40a,60a\"]\n"
"|==="

#: lecture.adoc:71
msgid ""
"|\n"
"`squashedStream`"
msgstr ""
"|\n"
"`squashedStream`"

#: lecture.adoc:73
msgid "image::filter.svg[]"
msgstr "image::filter.svg[]"

#: lecture.adoc:82
msgid ""
"`filteredStream`\n"
"|[source,java]\n"
"----\n"
"Stream<SquashedBlock> filteredStream =\n"
"  squashedStream.filter(block ‑> \n"
"         block.getColor() != YELLOW);\n"
"----\n"
"|==="
msgstr ""
"`filteredStream`\n"
"|[source,java]\n"
"----\n"
"Stream<SquashedBlock> filteredStream =\n"
"  squashedStream.filter(block ‑> \n"
"         block.getColor() != YELLOW);\n"
"----\n"
"|==="

#: lecture.adoc:84
msgid "== Отображаем в консоль (терминальная операция)"
msgstr "== Display in the console (terminal operation)"

#: lecture.adoc:87
msgctxt "lecture.adoc:87"
msgid ""
"[cols=\"^40a,60a\"]\n"
"|==="
msgstr ""
"[cols=\"^40a,60a\"]\n"
"|==="

#: lecture.adoc:90
msgid ""
"|\n"
"`filteredStream`"
msgstr ""
"|\n"
"`filteredStream`"

#: lecture.adoc:92
msgid "image::display.svg[]"
msgstr "image::display.svg[]"

#: lecture.adoc:99
msgid ""
"|[source,java]\n"
"----\n"
"filteredStream\n"
"  .forEach(System.out::println);\n"
"----\n"
"|==="
msgstr ""
"|[source,java]\n"
"----\n"
"filteredStream\n"
"  .forEach(System.out::println);\n"
"----\n"
"|==="

#: lecture.adoc:102
msgid "== Всё вместе в одну строку"
msgstr "== All together in one line"

#: lecture.adoc:115
msgid ""
"[cols=\"^40a,60a\"]\n"
"|===\n"
"|image::fuse.svg[]\n"
"|[source,java]\n"
"----\n"
"blocks.stream()\n"
"      .map(Block::squash)\n"
"      .filter(block ‑> \n"
"         block.getColor() != YELLOW)\n"
"      .forEach(System.out::println);\n"
"----\n"
"|==="
msgstr ""
"[cols=\"^40a,60a\"]\n"
"|===\n"
"|image::fuse.svg[]\n"
"|[source,java]\n"
"----\n"
"blocks.stream()\n"
"      .map(Block::squash)\n"
"      .filter(block ‑> \n"
"         block.getColor() != YELLOW)\n"
"      .forEach(System.out::println);\n"
"----\n"
"|==="

#: lecture.adoc:117
msgid "== Ничего не напоминает?"
msgstr "== Does it resemble something?"

#: lecture.adoc:119
msgid ""
"«Соединить два файла, привести их строки к lowercase, отсортировать, вывести "
"три последних строки в алфавитном порядке»"
msgstr ""
"\"Merge two files, convert lines to lowercase, sort, display the last three "
"lines in alphabetical order\""

#: lecture.adoc:122
msgid ""
"[source,sh]\n"
"cat file1 file2 | tr \"[A-Z]\" \"[a-z]\" | sort | tail -3"
msgstr ""
"[source,sh]\n"
"cat file1 file2 | tr \"[A-Z]\" \"[a-z]\" | sort | tail -3"

#: lecture.adoc:124
msgid "== Зачем это нужно?"
msgstr "== Why?"

#: lecture.adoc:133
msgid ""
"[cols=\"55a,45a\"]\n"
"|===\n"
"|*Java 7* | *Java 8*\n"
"|\n"
"[source,java]\n"
"----\n"
"Map<Currency, List<Transaction>>\n"
" transactionsByCurrencies = new HashMap<>();"
msgstr ""
"[cols=\"55a,45a\"]\n"
"|===\n"
"|*Java 7* | *Java 8*\n"
"|\n"
"[source,java]\n"
"----\n"
"Map<Currency, List<Transaction>>\n"
" transactionsByCurrencies = new HashMap<>();"

#: lecture.adoc:161
msgid ""
"for (Transaction transaction : transactions) {\n"
" Currency currency =transaction.getCurrency();\n"
" List<Transaction> transactionsForCurrency =\n"
"   transactionsByCurrencies.get(currency);\n"
" if (transactionsForCurrency == null) {\n"
"  transactionsForCurrency = new ArrayList<>();\n"
"    transactionsByCurrencies.put(currency,\n"
"           transactionsForCurrency); \n"
" }\n"
" transactionsForCurrency.add(transaction);\n"
"}\n"
"----\n"
"| \n"
"[source,java]\n"
"----\n"
"Map<Currency, \n"
" List<Transaction>>\n"
" transactionsByCurr =\n"
"   transactions\n"
"   .stream()\n"
"   .collect(\n"
"     Collectors\n"
"     .groupingBy(\n"
"   Transaction\n"
"   ::getCurrency));\n"
"----\n"
"|==="
msgstr ""
"for (Transaction transaction : transactions) {\n"
" Currency currency =transaction.getCurrency();\n"
" List<Transaction> transactionsForCurrency =\n"
"   transactionsByCurrencies.get(currency);\n"
" if (transactionsForCurrency == null) {\n"
"  transactionsForCurrency = new ArrayList<>();\n"
"    transactionsByCurrencies.put(currency,\n"
"           transactionsForCurrency); \n"
" }\n"
" transactionsForCurrency.add(transaction);\n"
"}\n"
"----\n"
"| \n"
"[source,java]\n"
"----\n"
"Map<Currency, \n"
" List<Transaction>>\n"
" transactionsByCurr =\n"
"   transactions\n"
"   .stream()\n"
"   .collect(\n"
"     Collectors\n"
"     .groupingBy(\n"
"   Transaction\n"
"   ::getCurrency));\n"
"----\n"
"|==="

#: lecture.adoc:163
msgid "== Три категории методов Stream API"
msgstr "== Three categories of Stream API methods"

#: lecture.adoc:168
msgid ""
"[source,java]\n"
"----\n"
"//Создание стрима\n"
"List<String> names = menu.stream()"
msgstr ""
"[source,java]\n"
"----\n"
"//Create a stream\n"
"List<String> names = menu.stream()"

#: lecture.adoc:173
msgid ""
"//Промежуточные операции\n"
"  .filter(d -> d.getCalories() > 300\n"
"  .map(Dish::getName)\n"
"  .limit(3)"
msgstr ""
"//Intermediate operations\n"
"  .filter(d -> d.getCalories() > 300\n"
"  .map(Dish::getName)\n"
"  .limit(3)"

#: lecture.adoc:177
msgid ""
"//Терминальная операция\n"
"  .collect(Collectors.toList());\n"
"----"
msgstr ""
"//Terminal operation\n"
"  .collect(Collectors.toList());\n"
"----"

#: lecture.adoc:179
msgid "== Создание стрима"
msgstr "== Creating a stream"

#: lecture.adoc:184
msgid ""
"[source,java]\n"
"----\n"
"//Пустого\n"
"Stream<Foo> stream0 = Stream.empty();"
msgstr ""
"[source,java]\n"
"----\n"
"//Empty stream\n"
"Stream<Foo> stream0 = Stream.empty();"

#: lecture.adoc:194
msgid ""
"//Перечислением элементов\n"
"Stream<String> stream1 = \n"
"         Stream.of(\"gently\", \"down\", \"the\", \"stream\");\n"
"//Из массива\n"
"Stream<String> stream2 =\n"
"         Arrays.stream(\"gently down the stream\".split(\" \"));\n"
"//Из коллекции\n"
"List<String> strings = ...\n"
"Stream<String> stream3 = strings.stream();"
msgstr ""
"//Enumerating elements\n"
"Stream<String> stream1 = \n"
"         Stream.of(\"gently\", \"down\", \"the\", \"stream\");\n"
"//From an array\n"
"Stream<String> stream2 =\n"
"         Arrays.stream(\"gently down the stream\".split(\" \"));\n"
"//From a collection\n"
"List<String> strings = ...\n"
"Stream<String> stream3 = strings.stream();"

#: lecture.adoc:199
msgid ""
"//Из API\n"
"Path path = Paths.get(...);\n"
"Stream<Path> stream4 = Files.list(path);\n"
"----"
msgstr ""
"//From API\n"
"Path path = Paths.get(...);\n"
"Stream<Path> stream4 = Files.list(path);\n"
"----"

#: lecture.adoc:201
msgid "== Конкатенация стримов"
msgstr "== Concatenation of streams"

#: lecture.adoc:208
msgid ""
"[source,java]\n"
"----\n"
"Stream<Foo> s1 = ...;\n"
"Stream<Foo> s2 = ...;\n"
"Stream<Foo> s = Stream.concat(s1, s2);\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"Stream<Foo> s1 = ...;\n"
"Stream<Foo> s2 = ...;\n"
"Stream<Foo> s = Stream.concat(s1, s2);\n"
"----"

#: lecture.adoc:210
msgid "== Порождение стримов (generate)"
msgstr "== Generating streams"

#: lecture.adoc:217
msgid ""
"[source,java]\n"
"----\n"
"//С помощью генератора\n"
"Stream<Double> randoms =\n"
"    Stream.generate(Math::random);\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"//Using a generator\n"
"Stream<Double> randoms =\n"
"    Stream.generate(Math::random);\n"
"----"

#: lecture.adoc:221
msgctxt "lecture.adoc:221"
msgid ""
"[.fragment]\n"
"[source,java]\n"
"----"
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"----"

#: lecture.adoc:226
msgid ""
"          //ХОТЯ ЛУЧШЕ\n"
"          DoubleStream doubles =\n"
"            ThreadLocalRandom.current().doubles()\n"
"----"
msgstr ""
"          //ALTHOUGH IT IS BETTER\n"
"          DoubleStream doubles =\n"
"            ThreadLocalRandom.current().doubles()\n"
"----"

#: lecture.adoc:228
msgid "== Порождение стримов (iterate)"
msgstr "== Producing stream elements with `iterate`"

#: lecture.adoc:235
msgid ""
"[source,java]\n"
"----\n"
"//Итеративно\n"
"Stream<Integer> integers =\n"
"    Stream.iterate(0, x -> x + 1);\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"//Iteratively\n"
"Stream<Integer> integers =\n"
"    Stream.iterate(0, x -> x + 1);\n"
"----"

#: lecture.adoc:239
msgctxt "lecture.adoc:239"
msgid ""
"[.fragment]\n"
"[source,java]\n"
"----"
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"----"

#: lecture.adoc:243
msgid ""
"          //ХОТЯ ЛУЧШЕ\n"
"          IntStream range = IntStream.range(0, 1000);\n"
"----"
msgstr ""
"          //ALTHOUGH IT IS BETTER\n"
"          IntStream range = IntStream.range(0, 1000);\n"
"----"

#: lecture.adoc:252
msgid ""
"== Что будет в этом стриме?\n"
"[source,java]\n"
"----\n"
"    Stream.iterate(new int[]{0, 1}, \n"
"                   t -> new int[]{t[1], t[0] + t[1]})\n"
"    .mapToInt(t -> t[0]);\n"
"----"
msgstr ""
"== What is the contents of this stream?\n"
"[source,java]\n"
"----\n"
"    Stream.iterate(new int[]{0, 1}, \n"
"                   t -> new int[]{t[1], t[0] + t[1]})\n"
"    .mapToInt(t -> t[0]);\n"
"----"

#: lecture.adoc:263
msgid ""
"== Spliterator: самый общий способ создания стрима\n"
"[source,java]\n"
"----\n"
"public interface Spliterator<T> {\n"
"  boolean tryAdvance(Consumer<? super T> action);\n"
"  Spliterator<T> trySplit();\n"
"  long estimateSize();\n"
"  int characteristics();\n"
"}\n"
"----"
msgstr ""
"== Spliterator: the most common way to create a stream\n"
"[source,java]\n"
"----\n"
"public interface Spliterator<T> {\n"
"  boolean tryAdvance(Consumer <? super T> action);\n"
"  Spliterator<T> trySplit();\n"
"  long estimateSize();\n"
"  int characteristics();\n"
"}\n"
"----"

#: lecture.adoc:268
msgid ""
"[source,java]\n"
"----\n"
"StreamSupport.stream(Spliterator<T> spliterator, boolean parallel)\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"StreamSupport.stream(Spliterator<T> spliterator, boolean parallel)\n"
"----"

#: lecture.adoc:280
msgid ""
"== Ветвление сплитераторов\n"
"[graphviz,\"split1.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"node[shape=\"box\"]\n"
"try[shape=\"none\"; label=\"trySplit()\"]\n"
"Spliterator1 -> try ;\n"
"try -> Spliterator2;\n"
"}\n"
"----"
msgstr ""
"== Spliterator branching\n"
"[graphviz,\"split1.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"node[shape=\"box\"]\n"
"try[shape=\"none\"; label=\"trySplit()\"]\n"
"Spliterator1 -> try ;\n"
"try -> Spliterator2;\n"
"}\n"
"----"

#: lecture.adoc:289
msgid ""
"== Ветвление сплитераторов\n"
"[graphviz,\"split2.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"node[shape=\"box\"]\n"
"try[shape=\"none\"; label=\"trySplit()\"]\n"
"try2[shape=\"none\"; label=\"trySplit()\"]"
msgstr ""
"== Spliterator branching\n"
"[graphviz,\"split2.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"node[shape=\"box\"]\n"
"try[shape=\"none\"; label=\"trySplit()\"]\n"
"try2[shape=\"none\"; label=\"trySplit()\"]"

#: lecture.adoc:295
msgid ""
"Spliterator1 -> Spliterator2 ;\n"
"Spliterator1 -> try2 -> Spliterator3;\n"
"Spliterator2 -> try -> Spliterator4;\n"
"}\n"
"----"
msgstr ""
"Spliterator1 -> Spliterator2 ;\n"
"Spliterator1 -> try2 -> Spliterator3;\n"
"Spliterator2 -> try -> Spliterator4;\n"
"}\n"
"----"

#: lecture.adoc:297
msgid "== Характеристики сплитератора"
msgstr "== Spliterator properties"

#: lecture.adoc:312
msgid ""
"[cols=\"15a,85a\"]\n"
"|===\n"
"|`ORDERED` |Elements have a defined order (for example, a `List`), so the "
"`Spliterator` enforces this\n"
"order when traversing and partitioning them.\n"
"|`DISTINCT`| For each pair of elements `x` and `y`, `x.equals(y)` returns "
"`false`.\n"
"|`SORTED`| The traversed elements follow a predefined sort order.\n"
"|`SIZED`| This `Spliterator` has been created from a source with a known "
"size, so the value returned by `estimatedSize()` is precise.\n"
"|`NONNULL`| It’s guaranteed that the traversed elements won’t be null.\n"
"|`IMMUTABLE`| The source of this `Spliterator` can’t be modified. This "
"implies that no elements can be\n"
"added, removed, or modified during their traversal.\n"
"|`CONCURRENT`| The source of this `Spliterator` may be safely concurrently "
"modified by other threads\n"
"without any synchronization.\n"
"|`SUBSIZED`| Both this `Spliterator` and all further `Spliterators` "
"resulting from its split are `SIZED`.\n"
"|==="
msgstr ""
"[cols=\"15a,85a\"]\n"
"|===\n"
"|`ORDERED` |Elements have a defined order (for example, a `List`), so the "
"`Spliterator` enforces this\n"
"order when traversing and partitioning them.\n"
"|`DISTINCT`| For each pair of elements `x` and `y`, `x.equals(y)` returns "
"`false`.\n"
"|`SORTED`| The traversed elements follow a predefined sort order.\n"
"|`SIZED`| This `Spliterator` has been created from a source with a known "
"size, so the value returned by `estimatedSize()` is precise.\n"
"|`NONNULL`| It’s guaranteed that the traversed elements won’t be null.\n"
"|`IMMUTABLE`| The source of this `Spliterator` can’t be modified. This "
"implies that no elements can be\n"
"added, removed, or modified during their traversal.\n"
"|`CONCURRENT`| The source of this `Spliterator` may be safely concurrently "
"modified by other threads\n"
"without any synchronization.\n"
"|`SUBSIZED`| Both this `Spliterator` and all further `Spliterators` "
"resulting from its split are `SIZED`.\n"
"|==="

#: lecture.adoc:315
msgid ""
"== Промежуточные итоги\n"
"* Есть много стандартных способов порождения стримов, для простых случаев не "
"надо \"изобретать велосипед\""
msgstr ""
"== Intermediate conclusions\n"
"* There are many standard ways to generate streams, for simple cases you do "
"not need to \"reinvent the wheel\""

#: lecture.adoc:318
msgid "* Скорей всего, вам не понадобится самому реализовывать `Spliterator`."
msgstr "* Most likely, you will not need to implement `Spliterator` yourself."

#: lecture.adoc:323
msgid ""
"* Быстродействия ради, есть \"примитивные стримы\" (три типа):\n"
"** `IntStream` (эффективнее, чем `Stream<Integer>`)\n"
"** `LongStream` (эффективнее, чем `Stream<Long>`)\n"
"** `DoubleStream` (эффективнее, чем `Stream<Double>`)"
msgstr ""
"* For the sake of performance, there are \"primitive streams\" (three "
"types):\n"
"** `IntStream` (more efficient than`<Integer>Stream`)\n"
"** `LongStream` (more efficient than`<Long>Stream`)\n"
"** `DoubleStream` (more efficient than`<Double>Stream`)"

#: lecture.adoc:325
msgid "== Преобразования стримов в стримы: получение «головы» и «хвоста»"
msgstr "== Convert streams to streams: getting \"head\" and \"tail\""

#: lecture.adoc:329
msgid ""
"[source,java]\n"
"----\n"
"//методы интерфейса Stream"
msgstr ""
"[source,java]\n"
"----\n"
"//Stream interface methods"

#: lecture.adoc:333
msgid ""
"//голова\n"
"Stream<T> limit(long maxSize)\n"
"Stream<T> takeWhile(Predicate<? super T> predicate)"
msgstr ""
"//head\n"
"Stream<T> limit(long maxSize)\n"
"Stream<T> takeWhile(Predicate<? super T> predicate)"

#: lecture.adoc:338
msgid ""
"//хвост\n"
"Stream<T> skip(long n)\n"
"Stream<T> dropWhile(Predicate<? super T> predicate)\n"
"----"
msgstr ""
"//tail\n"
"Stream<T> skip(long n)\n"
"Stream<T> dropWhile(Predicate<? super T> predicate)\n"
"----"

#: lecture.adoc:340
msgid "== filter "
msgstr "== filter "

#: lecture.adoc:351
msgid ""
"[cols=\"^40a,60a\"]\n"
"|===\n"
"|\n"
"image::filter.svg[]\n"
"|[source,java]\n"
"----\n"
"Stream<T> filter(\n"
"   Predicate<? super T> predicate);\n"
"----\n"
"|==="
msgstr ""
"[cols=\"^40a,60a\"]\n"
"|===\n"
"|\n"
"image::filter.svg[]\n"
"|[source,java]\n"
"----\n"
"Stream<T> filter(\n"
"   Predicate<? super T> predicate);\n"
"----\n"
"|==="

#: lecture.adoc:369
msgid ""
"== map \n"
"[cols=\"^40a,60a\"]\n"
"|===\n"
"|\n"
"image::map.svg[]\n"
"|[source,java]\n"
"----\n"
"<R> Stream<R> map(Function<? super T, \n"
"                           ? extends R> mapper);\n"
"IntStream mapToInt(\n"
"             ToIntFunction<? super T> mapper);\n"
"LongStream mapToLong(\n"
"            ToLongFunction<? super T> mapper);\n"
"DoubleStream mapToDouble(\n"
"          ToDoubleFunction<? super T> mapper);\n"
"----\n"
"|==="
msgstr ""
"== map \n"
"[cols=\"^40a,60a\"]\n"
"|===\n"
"|\n"
"image::map.svg[]\n"
"|[source,java]\n"
"----\n"
"<R> Stream<R> map(Function<? super T, \n"
"                           ? extends R> mapper);\n"
"IntStream mapToInt(\n"
"             ToIntFunction<? super T> mapper);\n"
"LongStream mapToLong(\n"
"            ToLongFunction<? super T> mapper);\n"
"DoubleStream mapToDouble(\n"
"          ToDoubleFunction<? super T> mapper);\n"
"----\n"
"|==="

#: lecture.adoc:371
msgid "== flatMap"
msgstr "== flatMap"

#: lecture.adoc:380
msgid ""
"[source,java]\n"
"----\n"
"Path path = ...\n"
"Pattern separator = Pattern.compile(\"\\\\s\");\n"
"try(Stream<String> lines = Files.lines(path, StandardCharsets.UTF_8)) {\n"
"    //НЕ ТО, что нам надо!\n"
"    //Stream<Stream<String>> streamStream = \n"
"    //                  lines.map(separator::splitAsStream);"
msgstr ""
"[source,java]\n"
"----\n"
"Path path = ...\n"
"Pattern separator = Pattern.compile(\"\\\\s\");\n"
"try(Stream<String> lines = Files.lines(path, StandardCharsets.UTF_8)) {\n"
"    //NOT what we need!\n"
"    //Stream<Stream<String>> streamStream = \n"
"    //                  lines.map(separator::splitAsStream);"

#: lecture.adoc:385
msgid ""
"    //ТО, что нам надо!\n"
"    Stream<String> words = lines.flatMap(separator::splitAsStream);\n"
"    words.forEach(System.out::println);\n"
"}"
msgstr ""
"    //Just what we need!\n"
"    Stream<String> words = lines.flatMap(separator::splitAsStream);\n"
"    words.forEach(System.out::println);\n"
"}"

#: lecture.adoc:392
msgid ""
"/*А также:\n"
"  flatMapToDouble\n"
"  flatMapToInt\n"
"  flatMapToLong\n"
"  */\n"
"----"
msgstr ""
"/*And also:\n"
"  flatMapToDouble\n"
"  flatMapToInt\n"
"  flatMapToLong\n"
"  */\n"
"----"

#: lecture.adoc:395
msgid "== distinct"
msgstr "== distinct"

#: lecture.adoc:399
msgid ""
"[source,java]\n"
"----\n"
"//Внутренний Set"
msgstr ""
"[source,java]\n"
"----\n"
"//Internal Set"

#: lecture.adoc:403
msgid ""
"Stream.of(1, 5, 8, 7, 8, 5, 9, 9)\n"
"    .distinct()\n"
"    .forEach(System.out::println);"
msgstr ""
"Stream.of(1, 5, 8, 7, 8, 5, 9, 9)\n"
"    .distinct()\n"
"    .forEach(System.out::println);"

#: lecture.adoc:406
msgid ""
"//Выведет 1, 5, 8, 7, 9\n"
"----"
msgstr ""
"//Outputs 1, 5, 8, 7, 9\n"
"----"

#: lecture.adoc:414
msgid ""
"== Что произойдёт при выполнении такого кода?\n"
"[source,java]\n"
"----\n"
"ThreadLocalRandom.current().ints(1, 10)\n"
"  .distinct()\n"
"  .forEach(System.out::println);\n"
"----"
msgstr ""
"== What happens when you execute this code?\n"
"[source,java]\n"
"----\n"
"ThreadLocalRandom.current().ints(1, 10)\n"
"  .distinct()\n"
"  .forEach(System.out::println);\n"
"----"

#: lecture.adoc:417
msgid ""
"[.fragment]\n"
"Программа зависнет, когда исчерпаются все значения от 1 до 10. Можно "
"пофиксить, например, указав `limit(9)` после distinct."
msgstr ""
"[.fragment]\n"
"The program will hang when all values from 1 to 10 are exhausted. You can "
"fix it, for example, by specifying `limit(9)` after `distinct`."

#: lecture.adoc:420
msgid "== sorted"
msgstr "== sorted"

#: lecture.adoc:424
msgid ""
"[source,java]\n"
"----\n"
"//Внутренний отсортированный список"
msgstr ""
"[source,java]\n"
"----\n"
"//Internal sorted list"

#: lecture.adoc:428
msgid ""
"Stream.of(1, 5, 8, 7, 8, 5, 9, 9)\n"
"    .sorted()\n"
"    .forEach(System.out::println);"
msgstr ""
"Stream.of(1, 5, 8, 7, 8, 5, 9, 9)\n"
"    .sorted()\n"
"    .forEach(System.out::println);"

#: lecture.adoc:430
msgid "//Выведет 1, 5, 5, 7, 8, 8, 9, 9"
msgstr "//Outputs 1, 5, 5, 7, 8, 8, 9, 9"

#: lecture.adoc:433
msgid ""
"//Не имеет смысла для бесконечных стримов\n"
"----"
msgstr ""
"//Doesn't make sense for infinite streams\n"
"----"

#: lecture.adoc:435
msgid "== peek -- отладочный метод"
msgstr "== peek -- debug method"

#: lecture.adoc:440
msgid ""
"* Не меняет исходный стрим.\n"
"* Предназначен для «подглядывания» за промежуточным состоянием элементов. \n"
"* В качестве аргумента часто используется `System.out::println`.\n"
"* При параллельных вычислениях может быть вызван в произвольном порядке в "
"произвольном потоке выполнения."
msgstr ""
"* Does not change the original stream.\n"
"* Designed to \"peek\" at the intermediate state of elements. \n"
"* `System.out::println` is often used as an argument.\n"
"* In parallel computations, it can be called in any order on in an arbitrary "
"thread."

#: lecture.adoc:443
msgid ""
"[source,java]\n"
"Stream<T> peek(Consumer<? super T> action);"
msgstr ""
"[source,java]\n"
"Stream<T> peek(Consumer<? super T> action);"

#: lecture.adoc:445
msgid "== Терминальные операции"
msgstr "== Terminal operations"

#: lecture.adoc:452
msgid ""
"[source,java]\n"
"----\n"
"//Предъяви первый элемент\n"
"Optional<T> findFirst();\n"
"//Предъяви любой элемент\n"
"Optional<T> findAny();"
msgstr ""
"[source,java]\n"
"----\n"
"//Present the first element\n"
"Optional<T> findFirst();\n"
"//Present any element\n"
"Optional<T> findAny();"

#: lecture.adoc:460
msgid ""
"//Проверь, удовлетворяет ли условию...\n"
"//...какой-то\n"
"boolean anyMatch(Predicate<? super T> predicate);\n"
"//...все\n"
"boolean allMatch(Predicate<? super T> predicate);\n"
"//...никакой\n"
"boolean noneMatch(Predicate<? super T> predicate);"
msgstr ""
"//Check to see if the condition is satisfied by...\n"
"//...at least one element\n"
"boolean anyMatch(Predicate<? super T> predicate);\n"
"//...all the elements\n"
"boolean allMatch(Predicate<? super T> predicate);\n"
"//...no element\n"
"boolean noneMatch(Predicate<? super T> predicate);"

#: lecture.adoc:463
msgid ""
"//КОРОТКИЕ ЗАМЫКАНИЯ!\n"
"----"
msgstr ""
"//SHORT CIRCUITING!\n"
"----"

#: lecture.adoc:465
msgid "== forEach"
msgstr "== forEach"

#: lecture.adoc:470
msgid ""
"[source,java]\n"
"----\n"
"void forEach(Consumer<? super T> action);\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"void forEach(Consumer<? super T> action);\n"
"----"

#: lecture.adoc:473
msgid ""
"* В случае параллельного выполнения нет гарантий последовательности\n"
"* Нет гарантий относительно того, в каком потоке будет выполнена лямбда"
msgstr ""
"* In the case of parallel execution, there are no guarantees of consistency\n"
"* There is no guarantee as to which thread the lambda will be executed on"

#: lecture.adoc:475
msgid "== reduce (with identity)"
msgstr "== reduce (with identity)"

#: lecture.adoc:483
msgid ""
"[cols=\"40a,60a\"]\n"
"|===\n"
"|\n"
"[graphviz, \"reduce1.png\"]\n"
"----\n"
"digraph G {\n"
"  graph [ dpi = 140 ];"
msgstr ""
"[cols=\"40a,60a\"]\n"
"|===\n"
"|\n"
"[graphviz, \"reduce1.png\"]\n"
"----\n"
"digraph G {\n"
"  graph [ dpi = 140 ];"

#: lecture.adoc:494
msgid ""
"  \"4\"[shape=\"square\"];\n"
"  \"5\"[shape=\"square\"];\n"
"  \"3\"[shape=\"square\"];\n"
"  \"9\"[shape=\"square\"];\n"
"  \"p1\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p2\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p3\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p4\"[label=\"+\"; shape=\"circle\"];\n"
"  \"4\" -> \"p1\";\n"
"  \"0\" -> \"p1\";"
msgstr ""
"  \"4\"[shape=\"square\"];\n"
"  \"5\"[shape=\"square\"];\n"
"  \"3\"[shape=\"square\"];\n"
"  \"9\"[shape=\"square\"];\n"
"  \"p1\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p2\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p3\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p4\"[label=\"+\"; shape=\"circle\"];\n"
"  \"4\" -> \"p1\";\n"
"  \"0\" -> \"p1\";"

#: lecture.adoc:505
msgid ""
"  \"p1\" -> \"s1\";\n"
"  \"5\" -> \"p2\";\n"
"  \"s1\" -> \"p2\";\n"
"  \"p2\" -> \"s2\";\n"
"  \"3\"-> \"p3\";\n"
"  \"s2\"->\"p3\";\n"
"  \"p3\"->\"s3\";\n"
"  \"9\"->\"p4\";\n"
"  \"s3\"->\"p4\";\n"
"  \"p4\"->\"s4\";"
msgstr ""
"  \"p1\" -> \"s1\";\n"
"  \"5\" -> \"p2\";\n"
"  \"s1\" -> \"p2\";\n"
"  \"p2\" -> \"s2\";\n"
"  \"3\"-> \"p3\";\n"
"  \"s2\"->\"p3\";\n"
"  \"p3\"->\"s3\";\n"
"  \"9\"->\"p4\";\n"
"  \"s3\"->\"p4\";\n"
"  \"p4\"->\"s4\";"

#: lecture.adoc:511
msgid ""
"  \"0\"[shape=\"square\"];\n"
"  \"s1\"[shape=\"square\";label=\"4\"];\n"
"  \"s2\"[shape=\"square\";label=\"9\"];\n"
"  \"s3\"[shape=\"square\";label=\"12\"];\n"
"  \"s4\"[shape=\"square\";label=\"21\"];"
msgstr ""
"  \"0\"[shape=\"square\"];\n"
"  \"s1\"[shape=\"square\";label=\"4\"];\n"
"  \"s2\"[shape=\"square\";label=\"9\"];\n"
"  \"s3\"[shape=\"square\";label=\"12\"];\n"
"  \"s4\"[shape=\"square\";label=\"21\"];"

#: lecture.adoc:513
msgctxt "lecture.adoc:513"
msgid "  \"0\"->\"4\"->\"5\"->\"3\"->\"9\"[style=\"invis\"]"
msgstr "  \"0\"->\"4\"->\"5\"->\"3\"->\"9\"[style=\"invis\"]"

#: lecture.adoc:522
msgid ""
"  {rank = same; \"4\"; \"5\"; \"3\"; \"9\";}\n"
"  {rank = same; \"0\"; \"p1\";}\n"
"  {rank = same; \"s1\"; \"p2\";}\n"
"  {rank = same; \"s2\"; \"p3\";}\n"
"  {rank = same; \"s3\"; \"p4\";}\n"
"}\n"
"----\n"
"| "
msgstr ""
"  {rank = same; \"4\"; \"5\"; \"3\"; \"9\";}\n"
"  {rank = same; \"0\"; \"p1\";}\n"
"  {rank = same; \"s1\"; \"p2\";}\n"
"  {rank = same; \"s2\"; \"p3\";}\n"
"  {rank = same; \"s3\"; \"p4\";}\n"
"}\n"
"----\n"
"| "

#: lecture.adoc:532
msgid ""
"* Ассоциативная функция + \"identity value\"\n"
"* Промежуточные результаты -- immutable values\n"
"* Вопрос: назовите примеры ассоциативных операций в математике?\n"
"[source,java]\n"
"----\n"
"T reduce(T identity, \n"
"  BinaryOperator<T> accumulator);\n"
"----\n"
"|==="
msgstr ""
"* Associative function + \"identity value\"\n"
"* Intermediate results are immutable values\n"
"* Question: What are some examples of associative operations in "
"mathematics?\n"
"[source,java]\n"
"----\n"
"T reduce(T identity, \n"
"  BinaryOperator<T> accumulator);\n"
"----\n"
"|==="

#: lecture.adoc:534
msgid "== Parallel reduce"
msgstr "== Parallel reduce"

#: lecture.adoc:551
msgid ""
"[graphviz, \"reduce-par.png\"]\n"
"----\n"
"digraph G {\n"
"  graph [ dpi = 150 ];\n"
"  \"4\"[shape=\"square\"];\n"
"  \"5\"[shape=\"square\"];\n"
"  \"3\"[shape=\"square\"];\n"
"  \"9\"[shape=\"square\"];\n"
"  \"p1\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p2\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p3\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p4\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p5\"[label=\"+\"; shape=\"circle\"];\n"
"  \"4\" -> \"p1\";\n"
"  \"0\" -> \"p1\";\n"
"  \"0\" -> \"p3\";"
msgstr ""
"[graphviz, \"reduce-par.png\"]\n"
"----\n"
"digraph G {\n"
"  graph [ dpi = 150 ];\n"
"  \"4\"[shape=\"square\"];\n"
"  \"5\"[shape=\"square\"];\n"
"  \"3\"[shape=\"square\"];\n"
"  \"9\"[shape=\"square\"];\n"
"  \"p1\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p2\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p3\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p4\"[label=\"+\"; shape=\"circle\"];\n"
"  \"p5\"[label=\"+\"; shape=\"circle\"];\n"
"  \"4\" -> \"p1\";\n"
"  \"0\" -> \"p1\";\n"
"  \"0\" -> \"p3\";"

#: lecture.adoc:564
msgid ""
"  \"p1\" -> \"s1\";\n"
"  \"5\" -> \"p2\";\n"
"  \"s1\" -> \"p2\";\n"
"  \"p2\" -> \"s2\";\n"
"  \"3\"-> \"p3\";\n"
"  //\"s2\"->\"p3\";\n"
"  \"p3\"->\"s3\";\n"
"  \"9\"->\"p4\";\n"
"  \"s3\"->\"p4\";\n"
"  \"p4\"->\"s4\";\n"
"  \"p5\"->\"s4\"[dir=back];\n"
"  \"s2\"->\"p5\";"
msgstr ""
"  \"p1\" -> \"s1\";\n"
"  \"5\" -> \"p2\";\n"
"  \"s1\" -> \"p2\";\n"
"  \"p2\" -> \"s2\";\n"
"  \"3\"-> \"p3\";\n"
"  //\"s2\"->\"p3\";\n"
"  \"p3\"->\"s3\";\n"
"  \"9\"->\"p4\";\n"
"  \"s3\"->\"p4\";\n"
"  \"p4\"->\"s4\";\n"
"  \"p5\"->\"s4\"[dir=back];\n"
"  \"s2\"->\"p5\";"

#: lecture.adoc:566
msgid "  \"p5\"->\"s5\";"
msgstr "  \"p5\"->\"s5\";"

#: lecture.adoc:574
msgid ""
"  \"0\"[shape=\"square\"];\n"
"  \"s1\"[shape=\"square\";label=\"4\"];\n"
"  \"s2\"[shape=\"square\";label=\"9\"];\n"
"  \"s3\"[shape=\"square\";label=\"3\"];\n"
"  \"s4\"[shape=\"square\";label=\"12\"];\n"
"  \"s5\"[shape=\"square\";label=\"21\"];"
msgstr ""
"  \"0\"[shape=\"square\"];\n"
"  \"s1\"[shape=\"square\";label=\"4\"];\n"
"  \"s2\"[shape=\"square\";label=\"9\"];\n"
"  \"s3\"[shape=\"square\";label=\"3\"];\n"
"  \"s4\"[shape=\"square\";label=\"12\"];\n"
"  \"s5\"[shape=\"square\";label=\"21\"];"

#: lecture.adoc:577
msgctxt "lecture.adoc:577"
msgid "  \"0\"->\"4\"->\"5\"->\"3\"->\"9\"[style=\"invis\"]"
msgstr "  \"0\"->\"4\"->\"5\"->\"3\"->\"9\"[style=\"invis\"]"

#: lecture.adoc:586
msgid ""
"  {rank = same; \"4\"; \"5\"; \"3\"; \"9\";}\n"
"  {rank = same; \"0\"; \"p1\"; \"p3\"}\n"
"  {rank = same; \"s1\"; \"p2\";}\n"
"  //{rank = same; \"s2\"; \"p3\";}\n"
"  {rank = same; \"s3\"; \"p4\";}\n"
"  {rank = same; \"s2\"; \"s4\"; \"p5\";}\n"
"}\n"
"----"
msgstr ""
"  {rank = same; \"4\"; \"5\"; \"3\"; \"9\";}\n"
"  {rank = same; \"0\"; \"p1\"; \"p3\"}\n"
"  {rank = same; \"s1\"; \"p2\";}\n"
"  //{rank = same; \"s2\"; \"p3\";}\n"
"  {rank = same; \"s3\"; \"p4\";}\n"
"  {rank = same; \"s2\"; \"s4\"; \"p5\";}\n"
"}\n"
"----"

#: lecture.adoc:599
msgid ""
"== reduce без identity\n"
"[cols=\"40a,60a\"]\n"
"|===\n"
"|\n"
"[graphviz, \"reduce2.png\"]\n"
"----\n"
"digraph G {\n"
"  graph [ dpi = 140 ];\n"
"  \"4\"[shape=\"square\"];\n"
"  \"5\"[shape=\"square\"];\n"
"  \"3\"[shape=\"square\"];\n"
"  \"9\"[shape=\"square\"];"
msgstr ""
"== reduce without identity\n"
"[cols=\"40a,60a\"]\n"
"|===\n"
"|\n"
"[graphviz, \"reduce2.png\"]\n"
"----\n"
"digraph G {\n"
"  graph [ dpi = 140 ];\n"
"  \"4\"[shape=\"square\"];\n"
"  \"5\"[shape=\"square\"];\n"
"  \"3\"[shape=\"square\"];\n"
"  \"9\"[shape=\"square\"];"

#: lecture.adoc:613
msgid ""
"  \"p2\"[label=\"max\"; shape=\"circle\"];\n"
"  \"p3\"[label=\"max\"; shape=\"circle\"];\n"
"  \"p4\"[label=\"max\"; shape=\"circle\"];\n"
"  \"4\" -> \"s1\";\n"
"  \"5\" -> \"p2\";\n"
"  \"s1\" -> \"p2\";\n"
"  \"p2\" -> \"s2\";\n"
"  \"3\"-> \"p3\";\n"
"  \"s2\"->\"p3\";\n"
"  \"p3\"->\"s3\";\n"
"  \"9\"->\"p4\";\n"
"  \"s3\"->\"p4\";\n"
"  \"p4\"->\"s4\";"
msgstr ""
"  \"p2\"[label=\"max\"; shape=\"circle\"];\n"
"  \"p3\"[label=\"max\"; shape=\"circle\"];\n"
"  \"p4\"[label=\"max\"; shape=\"circle\"];\n"
"  \"4\" -> \"s1\";\n"
"  \"5\" -> \"p2\";\n"
"  \"s1\" -> \"p2\";\n"
"  \"p2\" -> \"s2\";\n"
"  \"3\"-> \"p3\";\n"
"  \"s2\"->\"p3\";\n"
"  \"p3\"->\"s3\";\n"
"  \"9\"->\"p4\";\n"
"  \"s3\"->\"p4\";\n"
"  \"p4\"->\"s4\";"

#: lecture.adoc:618
msgid ""
"  \"s1\"[shape=\"square\";label=\"4\"];\n"
"  \"s2\"[shape=\"square\";label=\"5\"];\n"
"  \"s3\"[shape=\"square\";label=\"5\"];\n"
"  \"s4\"[shape=\"square\";label=\"9\"];"
msgstr ""
"  \"s1\"[shape=\"square\";label=\"4\"];\n"
"  \"s2\"[shape=\"square\";label=\"5\"];\n"
"  \"s3\"[shape=\"square\";label=\"5\"];\n"
"  \"s4\"[shape=\"square\";label=\"9\"];"

#: lecture.adoc:621
msgid "  \"4\"->\"5\"->\"3\"->\"9\"[style=\"invis\"]"
msgstr "  \"4\"->\"5\"->\"3\"->\"9\"[style=\"invis\"]"

#: lecture.adoc:629
msgid ""
"  {rank = same; \"4\"; \"5\"; \"3\"; \"9\";}\n"
"  {rank = same; \"s1\"; \"p2\";}\n"
"  {rank = same; \"s2\"; \"p3\";}\n"
"  {rank = same; \"s3\"; \"p4\";}\n"
"}\n"
"----\n"
"| * identity не нужно, но и результата может не получиться (если стрим "
"пустой)"
msgstr ""
"  {rank = same; \"4\"; \"5\"; \"3\"; \"9\";}\n"
"  {rank = same; \"s1\"; \"p2\";}\n"
"  {rank = same; \"s2\"; \"p3\";}\n"
"  {rank = same; \"s3\"; \"p4\";}\n"
"}\n"
"----\n"
"| * identity is not required, but the result may be empty (if the stream "
"itself is empty)"

#: lecture.adoc:634
msgid ""
"[source,java]\n"
"Optional<T> reduce(\n"
"  BinaryOperator<T> accumulator);\n"
"|==="
msgstr ""
"[source,java]\n"
"Optional<T> reduce(\n"
"  BinaryOperator<T> accumulator);\n"
"|==="

#: lecture.adoc:636
msgid "== Готовые редьюсы"
msgstr "== Ready-made 'reduce' operations"

#: lecture.adoc:644
msgid ""
"* Доступный во всех стримах:\n"
"** `count` -- в общем случае требует пересчёта всех элементов!\n"
"** `max(Comparator)`, `min(Comparator)`\n"
"* Доступные в стримах примитивов:\n"
"** `sum`\n"
"** `average`\n"
"** `summaryStatistics` -- count, sum, min и max «в одном флаконе»."
msgstr ""
"* Available in all streams:\n"
"** `count` -- generally it requires all elements to be computed!\n"
"** `max(Comparator)`, `min(Comparator)`\n"
"* Available in streams of primitives:\n"
"** `sum`\n"
"** `average`\n"
"** `summaryStatistics` -- count, sum, min and max in a single method."

#: lecture.adoc:646
msgid "== collect: самый гибкий метод сборки результатов"
msgstr "== collect: the most flexible method of assembling the results"

#: lecture.adoc:652
msgid ""
"* Типовые параметры:\n"
"** `T` -- тип элементов стрима\n"
"** `A` -- тип аккумулятора, промежуточной структуры данных, в которой всё "
"собирается\n"
"** `R` -- тип результата\n"
"* В отличие от `reduce`, работающего с иммутабельными объектами, мутирует "
"аккумулятор."
msgstr ""
"* Type parameters:\n"
"** `T` -- type of stream elements\n"
"** `A` is the type of accumulator, the intermediate data structure in which "
"everything is collected\n"
"** `R` -- result type\n"
"* Unlike `reduce`, which works with immutable objects, it mutates the "
"accumulator."

#: lecture.adoc:655
msgid ""
"[source,java]\n"
"<R, A> R collect(Collector<? super T, A, R> collector);"
msgstr ""
"[source,java]\n"
"<R, A> R collect(Collector<? super T, A, R> collector);"

#: lecture.adoc:657
msgid "== Интерфейс Collector<T, A, R>"
msgstr "== `Collector<T, A, R>` interface"

#: lecture.adoc:661
msgid ""
"* `T` -- тип элементов стрима\n"
"* `A` -- тип аккумулятора, промежуточной структуры данных, в которой всё "
"собирается\n"
"* `R` -- тип результата"
msgstr ""
"* `T` -- type of stream elements\n"
"* `A` is the type of accumulator, the intermediate data structure in which "
"everything is collected\n"
"* `R` -- result type"

#: lecture.adoc:671
msgid ""
"[source,java]\n"
"----\n"
"public interface Collector<T, A, R> {\n"
"  Supplier<A> supplier();\n"
"  BiConsumer<A, T> accumulator();\n"
"  Function<A, R> finisher();\n"
"  BinaryOperator<A> combiner();\n"
"  Set<Characteristics> characteristics();\n"
"}"
msgstr ""
"[source,java]\n"
"----\n"
"public interface Collector<T, A, R> {\n"
"  Supplier<A> supplier();\n"
"  BiConsumer<A, T> accumulator();\n"
"  Function<A, R> finisher();\n"
"  BinaryOperator<A> combiner();\n"
"  Set<Characteristics> characteristics();\n"
"}"

#: lecture.adoc:676
msgid ""
"//например:\n"
"class ToListCollector<T> implements\n"
"   Collector<T, List<T>, List<T>>\n"
"----"
msgstr ""
"//For example:\n"
"class ToListCollector<T> implements\n"
"   Collector<T, List<T>, List<T>>\n"
"----"

#: lecture.adoc:678
msgid "== Характеристики коллектора"
msgstr "== Collector properties"

#: lecture.adoc:686
msgid ""
"[cols=\"20a,80a\"]\n"
"|===\n"
"|*Characteristic* | *Meaning*\n"
"|`CONCURRENT`| Indicates that this collector is_concurrent_, meaning that "
"the result container can support the accumulator function being called "
"concurrently with the same result container from multiple threads.\n"
"|`UNORDERED`| Indicates that the collection operation does not commit to "
"preserving the encounter order of input elements.  (This might be true if "
"the result container has no intrinsic order, such as a `Set`.)\n"
"|`IDENTITY_FINISH`| Indicates that the finisher function is the identity "
"function and can be elided.  If set, it must be the case that an unchecked "
"cast from A to R will succeed.\n"
"|==="
msgstr ""
"[cols=\"20a,80a\"]\n"
"|===\n"
"|*Characteristic* | *Meaning*\n"
"|`CONCURRENT`| Indicates that this collector is_concurrent_, meaning that "
"the result container can support the accumulator function being called "
"concurrently with the same result container from multiple threads.\n"
"|`UNORDERED`| Indicates that the collection operation does not commit to "
"preserving the encounter order of input elements.  (This might be true if "
"the result container has no intrinsic order, such as a `Set`.)\n"
"|`IDENTITY_FINISH`| Indicates that the finisher function is the identity "
"function and can be elided.  If set, it must be the case that an unchecked "
"cast from A to R will succeed.\n"
"|==="

#: lecture.adoc:690
msgid ""
"== Промежуточные выводы\n"
"* Сделать свой коллектор непросто,\n"
"* Но сила коллекторов в том, что есть много готовых и их можно комбинировать!"
msgstr ""
"== Intermediate conclusions\n"
"* Making your own collector is not easy,\n"
"* But good news is that there are many ready-made ones and they can be "
"combined!"

#: lecture.adoc:692
msgid "== Наиболее употребимые коллекторы"
msgstr "== Most used collectors"

#: lecture.adoc:700
msgid ""
"[source,java]\n"
"----\n"
"//java.util.stream.Collectors\n"
"Collector<T, ?, List<T>> toList()\n"
"Collector<T, ?, Set<T>> toSet()\n"
"Collector<T, ?, C extends Collection<T>> \n"
"  toCollection(Supplier<C> collectionFactory)"
msgstr ""
"[source,java]\n"
"----\n"
"//java.util.stream.Collectors\n"
"Collector<T, ?, List<T>> toList()\n"
"Collector<T, ?, Set<T>> toSet()\n"
"Collector<T, ?, C extends Collection<T>> \n"
"  toCollection(Supplier<C> collectionFactory)"

#: lecture.adoc:705
msgid ""
"//Пример применения\n"
"Stream<Foo> myStream = ...\n"
"List<Foo> list = myStream.collect(Collectors.toList());\n"
"----"
msgstr ""
"//Usage example\n"
"Stream<Foo> myStream = ...\n"
"List<Foo> list = myStream.collect(Collectors.toList());\n"
"----"

#: lecture.adoc:712
msgid ""
"== Собирание в мапы\n"
"[source,java]\n"
"----\n"
"Collector<T, ?, Map<K,U>> toMap(\n"
"  Function<? super T, ? extends K> keyMapper,\n"
"  Function<? super T, ? extends U> valueMapper)"
msgstr ""
"== Collecting to maps\n"
"[source,java]\n"
"----\n"
"Collector<T, ?, Map<K,U>> toMap(\n"
"  Function<? super T, ? extends K> keyMapper,\n"
"  Function<? super T, ? extends U> valueMapper)"

#: lecture.adoc:718
msgid ""
"//Пример применения\n"
"Stream<Person> people = ...\n"
"Map<Integer, Person> idToPerson = people.collect(\n"
"  Collectors.toMap(Person::getId, p->p);\n"
"----"
msgstr ""
"//Usage example\n"
"Stream<Person> people = ...\n"
"Map<Integer, Person> idToPerson = people.collect(\n"
"  Collectors.toMap(Person::getId, p->p);\n"
"----"

#: lecture.adoc:720
msgid "* Также можно указать `mergeFunction` и `mapSupplier`."
msgstr "* You can also specify `mergeFunction` and `mapSupplier`."

#: lecture.adoc:723
msgid "== Вариации на тему сборки в коллекции"
msgstr "== Variations on the theme of the collecting"

#: lecture.adoc:726
msgid ""
"* с помощью `toUnmodifiable(List|Set|Map)` можно сразу получить неизменяемую "
"коллекцию\n"
"* `toConcurrentMap` можно сразу получить потокобезопасную мапу."
msgstr ""
"* `toUnmodifiable(List| Set| Map)` yields an immutable collection\n"
"* `toConcurrentMap` yields a thread-safe map."

#: lecture.adoc:728
msgid "== Строка с разделителями"
msgstr "== Delimited string"

#: lecture.adoc:732
msgid ""
"[source,java]\n"
"----\n"
"static Collector<CharSequence, ?, String> joining()"
msgstr ""
"[source,java]\n"
"----\n"
"static Collector<CharSequence, ?, String> joining()"

#: lecture.adoc:735
msgid ""
"//Пример использования\n"
"menuStream.map(Dish::getName).collect(Collectors.joining(\", \");"
msgstr ""
"//Usage example\n"
"menuStream.map(Dish::getName).collect(Collectors.joining(\", \");"

#: lecture.adoc:740
msgid ""
"//Не забываем про то, что это же можно сделать и без стримов:\n"
"static String join(CharSequence delimiter,\n"
"            Iterable<? extends CharSequence> elements)\n"
"----"
msgstr ""
"//Do not forget that this can be done without streams:\n"
"static String join(CharSequence delimiter,\n"
"            Iterable<? extends CharSequence> elements)\n"
"----"

#: lecture.adoc:742
msgid "== Группировки"
msgstr "== Groupings"

#: lecture.adoc:748
msgid ""
"[graphviz, \"groupby.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"node[shape=\"record\"]"
msgstr ""
"[graphviz, \"groupby.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"node[shape=\"record\"]"

#: lecture.adoc:750
msgctxt "lecture.adoc:750"
msgid "map[label=\"<f0>FISH|<f1>MEAT|<f2>OTHER\"];"
msgstr "map[label=\"<f0>FISH|<f1>MEAT|<f2>OTHER\"];"

#: lecture.adoc:757
msgid ""
"flist[label=\"{salmon|prawns}\"];\n"
"mlist[label=\"{pork|beef|chicken}\"];\n"
"olist[label=\"{pizza|rice|fruit|french fries}\"];\n"
"map:f0->flist;\n"
"map:f1->mlist;\n"
"map:f2->olist;"
msgstr ""
"flist[label=\"{salmon|prawns}\"];\n"
"mlist[label=\"{pork|beef|chicken}\"];\n"
"olist[label=\"{pizza|rice|fruit|french fries}\"];\n"
"map:f0->flist;\n"
"map:f1->mlist;\n"
"map:f2->olist;"

#: lecture.adoc:765
msgid ""
"}\n"
"----\n"
"[source,java]\n"
"----\n"
"Map<Dish.Type, List<Dish>> dishesByType =\n"
"  menu.stream().collect(Collectors.groupingBy(Dish::getType));\n"
"----"
msgstr ""
"}\n"
"----\n"
"[source,java]\n"
"----\n"
"Map<Dish.Type, List<Dish>> dishesByType =\n"
"  menu.stream().collect(Collectors.groupingBy(Dish::getType));\n"
"----"

#: lecture.adoc:772
msgid ""
"== Downstream Collectors\n"
"[graphviz, \"groupbyby.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"node[shape=\"record\"]"
msgstr ""
"== Downstream Collectors\n"
"[graphviz, \"groupbyby.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"node[shape=\"record\"]"

#: lecture.adoc:774
msgctxt "lecture.adoc:774"
msgid "map[label=\"<f0>FISH|<f1>MEAT|<f2>OTHER\"];"
msgstr "map[label=\"<f0>FISH|<f1>MEAT|<f2>OTHER\"];"

#: lecture.adoc:776
msgid "fmap[label=\"<f0>NORMAL|<f1>DIET\"];"
msgstr "fmap[label=\"<f0>NORMAL|<f1>DIET\"];"

#: lecture.adoc:778
msgid "mmap[label=\"<f0>FAT|<f1>NORMAL|<f2>DIET\"];"
msgstr "mmap[label=\"<f0>FAT|<f1>NORMAL|<f2>DIET\"];"

#: lecture.adoc:780
msgid "omap[label=\"<f0>NORMAL|<f1>DIET\"];"
msgstr "omap[label=\"<f0>NORMAL|<f1>DIET\"];"

#: lecture.adoc:783
msgid ""
"olist1[label=\"{pizza|french fries}\"];\n"
"olist2[label=\"{fruit|rice}\"];"
msgstr ""
"olist1[label=\"{pizza|french fries}\"];\n"
"olist2[label=\"{fruit|rice}\"];"

#: lecture.adoc:787
msgid ""
"map:f0->fmap;\n"
"map:f1->mmap;\n"
"map:f2->omap;"
msgstr ""
"map:f0->fmap;\n"
"map:f1->mmap;\n"
"map:f2->omap;"

#: lecture.adoc:790
msgid ""
"fmap:f0->salmon;\n"
"fmap:f1->prawns;"
msgstr ""
"fmap:f0->salmon;\n"
"fmap:f1->prawns;"

#: lecture.adoc:794
msgid ""
"mmap:f0->pork;\n"
"mmap:f1->beef;\n"
"mmap:f2->chicken;"
msgstr ""
"mmap:f0->pork;\n"
"mmap:f1->beef;\n"
"mmap:f2->chicken;"

#: lecture.adoc:797
msgid ""
"omap:f0->olist1;\n"
"omap:f1->olist2;"
msgstr ""
"omap:f0->olist1;\n"
"omap:f1->olist2;"

#: lecture.adoc:800
msgctxt "lecture.adoc:800"
msgid ""
"}\n"
"----"
msgstr ""
"}\n"
"----"

#: lecture.adoc:809
msgid ""
"[source,java]\n"
"----\n"
"Map<Dish.Type, Map<Dish.CaloricLevel, List<Dish>>>\n"
"  dishesByTypeAndCaloricLevel =\n"
"    menu.stream().collect(Collectors\n"
"      .groupingBy(Dish::getType,\n"
"         Collectors.groupingBy(Dish::getCaloricLevel)));\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"Map<Dish.Type, Map<Dish.CaloricLevel, List<Dish>>>\n"
"  dishesByTypeAndCaloricLevel =\n"
"    menu.stream().collect(Collectors\n"
"      .groupingBy(Dish::getType,\n"
"         Collectors.groupingBy(Dish::getCaloricLevel)));\n"
"----"

#: lecture.adoc:811
msgid "== Но мы можем не только группировать в цепочке!"
msgstr "== But we can perform other operations as well!"

#: lecture.adoc:816
msgid ""
"[graphviz, \"groupbyandcount.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];"
msgstr ""
"[graphviz, \"groupbyandcount.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];"

#: lecture.adoc:818
msgid "map[shape=\"record\";label=\"<f0>FISH|<f1>MEAT|<f2>OTHER\"];"
msgstr "map[shape=\"record\";label=\"<f0>FISH|<f1>MEAT|<f2>OTHER\"];"

#: lecture.adoc:825
msgid ""
"flist[label=\"2\"];\n"
"mlist[label=\"3\"];\n"
"olist[label=\"4\"];\n"
"map:f0->flist;\n"
"map:f1->mlist;\n"
"map:f2->olist;"
msgstr ""
"flist[label=\"2\"];\n"
"mlist[label=\"3\"];\n"
"olist[label=\"4\"];\n"
"map:f0->flist;\n"
"map:f1->mlist;\n"
"map:f2->olist;"

#: lecture.adoc:828
msgctxt "lecture.adoc:828"
msgid ""
"}\n"
"----"
msgstr ""
"}\n"
"----"

#: lecture.adoc:835
msgid ""
"[source,java]\n"
"----\n"
"Map<Dish.Type, Long> typesCount =\n"
"  menu.stream().collect(Collectors\n"
"    .groupingBy(Dish::getType, Collectors.counting()));\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"Map<Dish.Type, Long> typesCount =\n"
"  menu.stream().collect(Collectors\n"
"    .groupingBy(Dish::getType, Collectors.counting()));\n"
"----"

#: lecture.adoc:837
msgid "== Набор downstream collectors"
msgstr "== Downstream collectors set"

#: lecture.adoc:842
msgid ""
"[source,java]\n"
"----\n"
"/*Всё это уже есть в стримах, но нам надо применить это\n"
"к \"разветвлённому\" стриму.*/ "
msgstr ""
"[source,java]\n"
"----\n"
"/*All this is already present in the Stream API, but we need to apply it\n"
"to the \"branched\" stream.*/ "

#: lecture.adoc:852
msgid ""
"/*\"Терминальные\"*/\n"
"counting()\n"
"summingInt(ToIntFunction<? super T> mapper)\n"
"summingLong(ToLongFunction<? super T> mapper)\n"
"summingDouble(ToDoubleFunction<? super T> mapper)\n"
"maxBy(Comparator<? super T> comparator)\n"
"minBy(Comparator<? super T> comparator)\n"
"----"
msgstr ""
"/*\"Terminal\"*/\n"
"counting()\n"
"summingInt(ToIntFunction<? super T> mapper)\n"
"summingLong(ToLongFunction<? super T> mapper)\n"
"summingDouble(ToDoubleFunction<? super T> mapper)\n"
"maxBy(Comparator<? super T> comparator)\n"
"minBy(Comparator<? super T> comparator)\n"
"----"

#: lecture.adoc:861
msgid ""
"== Downstream collectors--продолжение\n"
"[source,java]\n"
"----\n"
"/*С возможностью продолжить цепочку*/\n"
"filtering(Predicate<? super T> predicate, downstream)\n"
"mapping(Function<? super T, ? extends U> mapper, downstream)\n"
"flatMapping(Function<? super T, \n"
"  ? extends Stream<? extends U>> mapper, downstream)"
msgstr ""
"== Downstream collectors continued\n"
"[source,java]\n"
"----\n"
"/*Giving an opportunity to continue the chain*/\n"
"filtering(Predicate<? super T> predicate, downstream)\n"
"mapping(Function<? super T, ? extends U> mapper, downstream)\n"
"flatMapping(Function<? super T, \n"
"  ? extends Stream<? extends U>> mapper, downstream)"

#: lecture.adoc:866
msgid ""
"/*Адаптор*/\n"
"collectingAndThen(Collector<T,A,R> downstream, \n"
"  Function<R,RR> finisher)\n"
"----"
msgstr ""
"/*Adaptor*/\n"
"collectingAndThen(Collector<T,A,R> downstream, \n"
"  Function<R,RR> finisher)\n"
"----"

#: lecture.adoc:868
msgid "== Когда может быть нужен collectingAndThen?"
msgstr "== When might `collectingAndThen` be needed?"

#: lecture.adoc:880
msgid ""
"[source,java]\n"
"----\n"
"Map<Dish.Type, Dish> mostCaloricByType = \n"
"  menu.stream()\n"
"     .collect(Collectors.groupingBy(Dish::getType,\n"
"       collectingAndThen( //<-----АДАПТОР\n"
"         Collectors.maxBy(Comparator\n"
"                   .comparingInt(Dish::getCalories),\n"
"         //maxBy возвращает Optional\n"
"       Optional::get)));\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"Map<Dish.Type, Dish> mostCaloricByType = \n"
"  menu.stream()\n"
"     .collect(Collectors.groupingBy(Dish::getType,\n"
"       collectingAndThen( //<-----ADAPTOR\n"
"         Collectors.maxBy(Comparator\n"
"                   .comparingInt(Dish::getCalories),\n"
"         //maxBy returns Optional\n"
"       Optional::get)));\n"
"----"

#: lecture.adoc:882
msgid "== Параллельные стримы"
msgstr "== Parallel streams"

#: lecture.adoc:886
msgid ""
"* Метод `.parallel()` включает параллелизацию обработки.\n"
"* `parallel` можно вызвать в любом месте цепочки вызовов.\n"
"* Пользоваться надо с осторожностью, понимая ограничения и применимость."
msgstr ""
"* The `.parallel()` method enables parallelization of processing.\n"
"* `parallel` can be called anywhere in the call chain.\n"
"* It should be used with caution, understanding the limitations and "
"applicability."

#: lecture.adoc:888
msgid "== Optional: Контейнер, который содержит объект. Или не содержит."
msgstr "== Optional: The container that contains an object. Or it doesn't."

#: lecture.adoc:890
msgid "* Цитата из книги Java 8 in Action:"
msgstr "* Quote from 'Java 8 in Action':"

#: lecture.adoc:892
msgid ""
"* \"Tony Hoare, one of the giants of computer science, said in a "
"presentation at QCon London 2009: _I call it my billion-dollar mistake. It "
"was the invention of the null reference in 1965.... I couldn’t resist the "
"temptation to put in a null reference, simply because it was so easy to "
"implement._\""
msgstr ""
"* \"Tony Hoare, one of the giants of computer science, said in a "
"presentation at QCon London 2009: _I call it my billion-dollar mistake. It "
"was the invention of the null reference in 1965.... I couldn’t resist the "
"temptation to put in a null reference, simply because it was so easy to "
"implement._\""

#: lecture.adoc:895
msgid "== Optional<T> -- как стрим из 0 или 1 элемента"
msgstr "== Optional<T> is like a stream of 0 or 1 element"

#: lecture.adoc:902
msgid ""
"[source,java]\n"
"----\n"
"//Создание\n"
"Optional.empty(); //пустой\n"
"Optional.of(x); //NPE если x == null\n"
"Optional.ofNullable(x); //пустой или с x-ом"
msgstr ""
"[source,java]\n"
"----\n"
"//Creating\n"
"Optional.empty(); //empty optional\n"
"Optional.of(x); //NPE if x == null\n"
"Optional.ofNullable(x); //empty or containing x"

#: lecture.adoc:909
msgid ""
"//Расчехление\n"
"o.get();\n"
"o.orElse(other);\n"
"o.orElseGet(()->calcOther());\n"
"o.orElseThrow(()->new IllegalStateException());\n"
"----"
msgstr ""
"//Unsheathing\n"
"o.get();\n"
"o.orElse(other);\n"
"o.orElseGet(()->calcOther());\n"
"o.orElseThrow(()->new IllegalStateException());\n"
"----"

#: lecture.adoc:916
msgid ""
"== Optional.map \n"
"[source,java]\n"
"----\n"
"Optional<Insurance> optInsurance = Optional.ofNullable(insurance);\n"
"Optional<String> name = optInsurance.map(Insurance::getName);\n"
"----"
msgstr ""
"== Optional.map \n"
"[source,java]\n"
"----\n"
"Optional<Insurance> optInsurance = Optional.ofNullable(insurance);\n"
"Optional<String> name = optInsurance.map(Insurance::getName);\n"
"----"

#: lecture.adoc:921
msgid ""
"== Optional.flatMap\n"
"[source,java]\n"
"----\n"
"Optional<Person> person = ..."
msgstr ""
"== Optional.flatMap\n"
"[source,java]\n"
"----\n"
"Optional<Person> person = ..."

#: lecture.adoc:923
msgid "//person.map(Person::getCar) вернёт Optional<Optional<Car>>!!"
msgstr "//person.map(Person::getCar) returns Optional<Optional<Car>>!!"

#: lecture.adoc:929
msgid ""
"String insuranceName = person.flatMap(Person::getCar)\n"
"                             .flatMap(Car::getInsurance)\n"
"                             .map(Insurance::getName)\n"
"                             .orElse(\"Unknown\");\n"
"----"
msgstr ""
"String insuranceName = person.flatMap(Person::getCar)\n"
"                             .flatMap(Car::getInsurance)\n"
"                             .map(Insurance::getName)\n"
"                             .orElse(\"Unknown\");\n"
"----"

#: lecture.adoc:931
msgid "== Optional.filter"
msgstr "== Optional.filter"

#: lecture.adoc:939
msgid ""
"[source,java]\n"
"----\n"
"String insuranceName = person.filter(p -> p.getAge() >= minAge)\n"
"                             .flatMap(Person::getCar)\n"
"                             .flatMap(Car::getInsurance)\n"
"                             .map(Insurance::getName)\n"
"                             .orElse(\"Unknown\");"
msgstr ""
"[source,java]\n"
"----\n"
"String insuranceName = person.filter(p -> p.getAge() >= minAge)\n"
"                             .flatMap(Person::getCar)\n"
"                             .flatMap(Car::getInsurance)\n"
"                             .map(Insurance::getName)\n"
"                             .orElse(\"Unknown\");"

#: lecture.adoc:941
msgid "----"
msgstr "----"

#: lecture.adoc:943
msgctxt "lecture.adoc:943"
msgid "== Правила использования Optional"
msgstr "== Rules of using Optional"

#: lecture.adoc:945
msgid "«Лобовое» использование `Optional` -- хуже, чем `null`:"
msgstr "Dumb usage of `Optional` is worse than `null`:"

#: lecture.adoc:961
msgid ""
"[cols=\"50a,50a\"]\n"
"|===\n"
"|*ПЛОХО* | *НОРМАЛЬНО*\n"
"|\n"
"[source,java]\n"
"----\n"
"if (o.isPresent())\n"
"  o.get().someMethod();\n"
"----\n"
"|\n"
"[source,java]\n"
"----\n"
"if (o != null)\n"
"  o.someMethod();\n"
"----"
msgstr ""
"[cols=\"50a,50a\"]\n"
"|===\n"
"|*WRONG* | *OK*\n"
"|\n"
"[source,java]\n"
"----\n"
"if (o.isPresent())\n"
"  o.get().someMethod();\n"
"----\n"
"|\n"
"[source,java]\n"
"----\n"
"if (o != null)\n"
"  o.someMethod();\n"
"----"

#: lecture.adoc:963
msgid "|==="
msgstr "|==="

#: lecture.adoc:965
msgctxt "lecture.adoc:965"
msgid "== Правила использования Optional"
msgstr "== Rules of using Optional"

#: lecture.adoc:970
msgid ""
"* Переменная с типом `Optional` никогда не должна быть `null`.\n"
"* Поля с типом `Optional` бесполезны: проверка на «непустоту» этого поля не "
"лучше проверки на `null`, цена -- дополнительный объект.\n"
"* Не кладите `Optional`-ы в коллекции.\n"
"* В целом, `Optional` -- для возвращаемых значений, а не для аргументов "
"методов."
msgstr ""
"* A variable of `Optional` type should never be `null`.\n"
"* Fields with the `Optional` type are useless: checking for \"not empty\" of "
"this field is no better than checking for `null`, the price is an additional "
"object.\n"
"* Never put `Optional` in a collection.\n"
"* In general, `Optional` is for return values, not method arguments."

#: lecture.adoc:972
msgid "== Когда стримы использовать не нужно"
msgstr "== When streams should not be used"

#: lecture.adoc:976
msgid ""
"* Стримы многим нравятся\n"
"* Иногда люди перестают думать, и случается «стримоз»\n"
"* Тагир Валеев: https://habr.com/ru/post/337350/[Используйте Stream API "
"проще (или не используйте вообще)]"
msgstr ""
"* Streams are liked by many\n"
"* Sometimes people stop thinking, and \"streamosis\" happens\n"
"* Tagir Valeev: https://medium.com/@tagir_valeev/use-stream-api-simpler-or-"
"dont-use-it-at-all-ea0a44a4b1ff[Use Stream API simpler (or don't use it at "
"all)]"

#: lecture.adoc:978
msgctxt "lecture.adoc:978"
msgid "== Что не так?"
msgstr "== What's wrong?"

#: lecture.adoc:981
msgid ""
"[source,java]\n"
"collection.stream().forEach(...)"
msgstr ""
"[source,java]\n"
"collection.stream().forEach(...)"

#: lecture.adoc:984
msgid ""
"[.fragment]\n"
"У класса `Collection` уже есть метод `forEach`, стрим создавать не нужно."
msgstr ""
"[.fragment]\n"
"The `Collection` class already has a `forEach` method, you do not need to "
"create a stream."

#: lecture.adoc:986
msgctxt "lecture.adoc:986"
msgid "== Что не так?"
msgstr "== What's wrong?"

#: lecture.adoc:990
msgid ""
"[source,java]\n"
"collection.stream().collect(Collectors.toList())\n"
"collection.stream().collect(Collectors.toSet())"
msgstr ""
"[source,java]\n"
"collection.stream().collect(Collectors.toList())\n"
"collection.stream().collect(Collectors.toSet())"

#: lecture.adoc:996
msgid ""
"[.fragment]\n"
"[source,java]\n"
"/*так эффективнее*/\n"
"new ArrayList<>(collection)\n"
"new HashSet<>(collection)"
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"/*more efficient*/\n"
"new ArrayList<>(collection)\n"
"new HashSet<>(collection)"

#: lecture.adoc:998
msgctxt "lecture.adoc:998"
msgid "== Что не так?"
msgstr "== What's wrong?"

#: lecture.adoc:1001
msgid ""
"[source,java]\n"
"collection.stream().max(Comparator.naturalOrder()).get()"
msgstr ""
"[source,java]\n"
"collection.stream().max(Comparator.naturalOrder()).get()"

#: lecture.adoc:1006
msgid ""
"[.fragment]\n"
"[source,java]\n"
"/*То же самое, с меньшим количеством мусора*/\n"
"Collections.max(collection)"
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"/*Same with less garbage*/\n"
"Collections.max(collection)"

#: lecture.adoc:1010
msgid ""
"== Что хотел сказать автор?\n"
"[source,java]\n"
"stream.sorted(comparator).findFirst()"
msgstr ""
"== What did the author want to say?\n"
"[source,java]\n"
"stream.sorted(comparator).findFirst()"

#: lecture.adoc:1014
msgid ""
"[.fragment]\n"
"[source,java]\n"
"stream.min(comparator)"
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"stream.min(comparator)"

#: lecture.adoc:1016
msgctxt "lecture.adoc:1016"
msgid "== Как улучшить?"
msgstr "== How to improve?"

#: lecture.adoc:1019
msgid ""
"[source,java]\n"
"stream.collect(Collectors.counting())"
msgstr ""
"[source,java]\n"
"stream.collect(Collectors.counting())"

#: lecture.adoc:1025
msgid ""
"[.fragment]\n"
"[source,java]\n"
"/*Коллекторы counting(), maxBy(), minBy(), reducing(), mapping(), ... \n"
"нужны лишь как вторичные в каскадных операциях groupingBy*/\n"
"stream.count()"
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"/*counting(), maxBy(), minBy(), reducing(), mapping(), etc collectors\n"
"are intended to be used in cascading groupingBy operations only!*/\n"
"stream.count()"

#: lecture.adoc:1027
msgid "== Что не так?!"
msgstr "== What's wrong?!"

#: lecture.adoc:1030
msgid ""
"[source,java]\n"
"collection.stream().count()"
msgstr ""
"[source,java]\n"
"collection.stream().count()"

#: lecture.adoc:1036
msgid ""
"[.fragment]\n"
"[source,java]\n"
"/*Без пересчёта элементов один за другим!*/\n"
"collection.size()"
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"/*Without counting the elements one after another!*/\n"
"collection.size()"

#: lecture.adoc:1041
msgid ""
"== Как улучшить?\n"
"[source,java]\n"
"listOfLists.stream().flatMap(List::stream).count()"
msgstr ""
"== How to improve?\n"
"[source,java]\n"
"listOfLists.stream().flatMap(List::stream).count()"

#: lecture.adoc:1046
msgid ""
"[.fragment]\n"
"[source,java]\n"
"/*Число элементов каждого подсписка известно!*/\n"
"listOfLists.stream().mapToInt(List::size).sum()"
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"/*The number of elements in each sublist is nown!*/\n"
"listOfLists.stream().mapToInt(List::size).sum()"

#: lecture.adoc:1048
msgctxt "lecture.adoc:1048"
msgid "== Как улучшить?"
msgstr "== How to improve?"

#: lecture.adoc:1051
msgid ""
"[source,java]\n"
"stream.filter(condition).findFirst().isPresent()"
msgstr ""
"[source,java]\n"
"stream.filter(condition).findFirst().isPresent()"

#: lecture.adoc:1056
msgid ""
"[.fragment]\n"
"[source,java]\n"
"/*Зачем сам элемент, если надо лишь проверить наличие?*/\n"
"stream.anyMatch(condition)"
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"/*Why getting the element itself if we just need to check its presence?*/\n"
"stream.anyMatch(condition)"

#: lecture.adoc:1058
msgctxt "lecture.adoc:1058"
msgid "== Как улучшить?"
msgstr "== How to improve?"

#: lecture.adoc:1064
msgid ""
"[source,java]\n"
"stream.filter(condition).anyMatch(x -> true)\n"
"stream.map(condition).anyMatch(b -> b)\n"
"stream.map(condition).anyMatch(Boolean::booleanValue)\n"
"stream.map(condition).anyMatch(Boolean.TRUE::equals)"
msgstr ""
"[source,java]\n"
"stream.filter(condition).anyMatch(x -> true)\n"
"stream.map(condition).anyMatch(b -> b)\n"
"stream.map(condition).anyMatch(Boolean::booleanValue)\n"
"stream.map(condition).anyMatch(Boolean.TRUE::equals)"

#: lecture.adoc:1069
msgid ""
"[.fragment]\n"
"[source,java]\n"
"/*Замысловатые вариации на простую тему*/\n"
"stream.anyMatch(condition)"
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"/*Intricate variations on a trivial theme*/\n"
"stream.anyMatch(condition)"

#: lecture.adoc:1072
msgctxt "lecture.adoc:1072"
msgid "== Как улучшить?!"
msgstr "== How to improve?!"

#: lecture.adoc:1075
msgid ""
"[source,java]\n"
"if(stream.filter(condition).count() > 0)"
msgstr ""
"[source,java]\n"
"if(stream.filter(condition).count() > 0)"

#: lecture.adoc:1081
msgid ""
"[.fragment]\n"
"[source,java]\n"
"/*В этом примере ещё хуже, чем в предыдущих,\n"
"т. к. обходится весь стрим целиком! А решение то же:*/\n"
"if(stream.anyMatch(condition)) "
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"/*This example is even worse than the previous ones,\n"
"because it traverses the whole stream! And the solution is the same:*/\n"
"if(stream.anyMatch(condition)) "

#: lecture.adoc:1083
msgctxt "lecture.adoc:1083"
msgid "== Как улучшить?!"
msgstr "== How to improve?!"

#: lecture.adoc:1086
msgid ""
"[source,java]\n"
"if(stream.count() > 2)"
msgstr ""
"[source,java]\n"
"if(stream.count() > 2)"

#: lecture.adoc:1091
msgid ""
"[.fragment]\n"
"[source,java]\n"
"/*Нам ведь неважно, сколько их, если их больше двух?*/\n"
"stream.limit(3).count()"
msgstr ""
"[.fragment]\n"
"[source,java]\n"
"/*We don't care how many there are if there are more than two*/\n"
"stream.limit(3).count()"

#: lecture.adoc:1093
msgid "== Выводы"
msgstr "== Conclusions"

#: lecture.adoc:1095
msgid ""
"* «Декларативный» подход к использованию стримов, «описываем _что_, а не "
"_как_» не отменяет понимания того, _как_ происходит вычисление. \n"
"* Применять стримы надо с умом, а много где их и не надо применять."
msgstr ""
"* The \"declarative\" approach, \"describing _what_, not _as_\" does not "
"devalue the understanding of _how_ the calculation occurs. \n"
"* Streams should be used wisely, and there are many cases where they should "
"not be used."

#~ msgid ""
#~ "//== Часть 1. Введение\n"
#~ ":!figure-caption:"
#~ msgstr ""
#~ "//== Часть 1. Введение\n"
#~ ":!figure-caption:"

#~ msgctxt "lecture.adoc:69"
#~ msgid ""
#~ "[cols=\"^40a,60a\"]\n"
#~ "|==="
#~ msgstr ""
#~ "[cols=\"^40a,60a\"]\n"
#~ "|==="

#~ msgctxt "lecture.adoc:88"
#~ msgid ""
#~ "[cols=\"^40a,60a\"]\n"
#~ "|==="
#~ msgstr ""
#~ "[cols=\"^40a,60a\"]\n"
#~ "|==="

#~ msgctxt "lecture.adoc:240"
#~ msgid ""
#~ "[.fragment]\n"
#~ "[source,java]\n"
#~ "----"
#~ msgstr ""
#~ "[.fragment]\n"
#~ "[source,java]\n"
#~ "----"

#~ msgctxt "lecture.adoc:578"
#~ msgid "  \"0\"->\"4\"->\"5\"->\"3\"->\"9\"[style=\"invis\"]"
#~ msgstr "  \"0\"->\"4\"->\"5\"->\"3\"->\"9\"[style=\"invis\"]"

#~ msgctxt "lecture.adoc:775"
#~ msgid "map[label=\"<f0>FISH|<f1>MEAT|<f2>OTHER\"];"
#~ msgstr "map[label=\"<f0>FISH|<f1>MEAT|<f2>OTHER\"];"

#~ msgctxt "lecture.adoc:829"
#~ msgid ""
#~ "}\n"
#~ "----"
#~ msgstr ""
#~ "}\n"
#~ "----"

#~ msgctxt "lecture.adoc:966"
#~ msgid "== Правила использования Optional"
#~ msgstr "== Rules of using Optional"

#~ msgctxt "lecture.adoc:987"
#~ msgid "== Что не так?"
#~ msgstr "== What's wrong?"

#~ msgctxt "lecture.adoc:999"
#~ msgid "== Что не так?"
#~ msgstr "== What's wrong?"

#~ msgctxt "lecture.adoc:1049"
#~ msgid "== Как улучшить?"
#~ msgstr "== How to improve?"

#~ msgctxt "lecture.adoc:1059"
#~ msgid "== Как улучшить?"
#~ msgstr "== How to improve?"

#~ msgctxt "lecture.adoc:1084"
#~ msgid "== Как улучшить?!"
#~ msgstr "== How to improve?!"

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:69"
#~ msgid ""
#~ "[cols=\"^40a,60a\"]\n"
#~ "|==="
#~ msgstr ""
#~ "[cols=\"^40a,60a\"]\n"
#~ "|==="

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:88"
#~ msgid ""
#~ "[cols=\"^40a,60a\"]\n"
#~ "|==="
#~ msgstr ""
#~ "[cols=\"^40a,60a\"]\n"
#~ "|==="

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:240"
#~ msgid ""
#~ "[.fragment]\n"
#~ "[source,java]\n"
#~ "----"
#~ msgstr ""
#~ "[.fragment]\n"
#~ "[source,java]\n"
#~ "----"

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:578"
#~ msgid "  \"0\"->\"4\"->\"5\"->\"3\"->\"9\"[style=\"invis\"]"
#~ msgstr "  \"0\"->\"4\"->\"5\"->\"3\"->\"9\"[style=\"invis\"]"

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:775"
#~ msgid "map[label=\"<f0>FISH|<f1>MEAT|<f2>OTHER\"];"
#~ msgstr "map[label=\"<f0>FISH|<f1>MEAT|<f2>OTHER\"];"

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:829"
#~ msgid ""
#~ "}\n"
#~ "----"
#~ msgstr ""
#~ "}\n"
#~ "----"

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:966"
#~ msgid "== Правила использования Optional"
#~ msgstr "== Правила использования Optional"

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:987"
#~ msgid "== Что не так?"
#~ msgstr "== Что не так?"

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:999"
#~ msgid "== Что не так?"
#~ msgstr "== Что не так?"

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:1049"
#~ msgid "== Как улучшить?"
#~ msgstr "== Как улучшить?"

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:1059"
#~ msgid "== Как улучшить?"
#~ msgstr "== Как улучшить?"

#~ msgctxt "./slides09/src/main/asciidoc/lecture.adoc:1084"
#~ msgid "== Как улучшить?!"
#~ msgstr "== Как улучшить?!"
